---
title: 事务(2)
typora-root-url: 事务(2)
date: 2026-01-23 15:34:48
tags: [MySQL]
categories: [MySQL]
description: 本篇文章主要讲讲MySQL事务的实现原理。
---

在上篇文章，我们讲到了MySQL事务的四个特性ACID。这次，从ACID的特性的实现原理来解析MySQL事务的实现原理。

## 1.原子性

原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。
当事务执行失败的时候，需要对已经执行的操作做回滚，在MySQL的InnoDB引擎中，使用undo log日志进行回滚

### 1.1 undo log

undo log是记录了相反的操作，比如insert一条记录，undo log就记录了一条delete，update一条记录，就记录一条相反的update记录。

undo log分为两种

- Insert类型：insert语句
- Update类型：update语句，delete语句

删除记录时，实际上并不是真的删除，而是修改一下Delete Mark标记，所以delete操作也是updat操作。

### 1.2 TODO

- undo log 持久化
- undo log 物理存储组织
- undo log清理



## 2. 持久性

事务一旦提交，对数据库的改变是永久的。数据持久化到磁盘中。

### 2.1 数据丢失？

因为数据最终要存储在硬盘当中，如果每次提交事务都直接保存到硬盘中，MySQL的速度会十分慢。所以在提交事务时，先保存到内存中， 再从内存中保存到硬盘中。从内存保存到硬盘中，可能会出现系统故障，比如断电，这时候就需要持久性。

### 2.2 Buffer Pool

InnoDB借助内存来提升操作效率。Buffer Pool是InnoDB实现的一个缓存模式。

- 读取数据时，MySQL会先访问Buffer Pool，有则返回，没有读取硬盘
- 修改数据，如果Buffer Pool中存在数据，直接修改Buffer Pool所在的数据页，标记为脏页，通过后台线程写回脏页。

InnoDB按16KB一页进行划分

### 2.3 redo log

上一条讲到，MySQL读取和修改数据都有通过内存，但是内存是做不到持久化的，需要同步到硬盘中。InnoDB 通过redo log来解决这个问题。

redo log是物理日志，记录了在哪一页的哪一个偏移量的修改。每当数据更新时，会把redo log记录到redo log buffer中，然后刷盘到redo log文件中。

**redo log也是将数据写入磁盘，为什么不直接将脏页写到磁盘中？**

- 将脏页写回磁盘是随机IO，redo log是追加操作，是顺序IO
- 脏页是以一个数据页为单位，需要将整页写入，redo log只包含真正要写入的

![img](/../事务-2/03.png)

#### 2.3.1 刷盘时机

- 0:事务提交时不刷盘，每秒刷盘一次
- 1:事务提交时立即刷盘
- 2:事务提交时写入操作系统缓存

#### 2.3.2 日志文件组

硬盘上存储的 redo log 日志文件不只一个，而是以一个**日志文件组**的形式出现的，每个的`redo`日志文件大小都是一样的。

比如可以配置为一组`4`个文件，每个文件的大小是 `1GB`，整个 redo log 日志文件组可以记录`4G`的内容。

它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写

![img](/../事务-2/10.png)

日志文件组中有write pos，checkpoint

- write pos记录当前位置，一边写一边往后移
- checkoutpoint是当前擦除的位置

每次刷盘redolog记录到日志文件组中，write pos位置后移。

次 MySQL 加载**日志文件组**恢复数据时，会清空加载过的 redo log 记录，并把 `checkpoint` 后移更新。`write pos` 和 `checkpoint` 之间的还空着的部分可以用来写入新的 redo log 记录。



## 3.隔离性

隔离性是事务和事务之间是隔离的。在InnoDB中，事务依靠锁和MVCC机制来实现。

- 一个事务写操作对另一个事务写操作的影响：锁机制
- 一个事务写操作对另一个事务读操作：MVCC

### 3.1 锁

同一时刻只能有一个事务对数据进行写操作。
锁机制可以概括为：
**事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。**

按照粒度，锁可以分为行锁和表锁以及其他锁。表锁在操作时会锁定整张表，行锁只锁定一条记录。所以行锁比表锁的性能更好。

### 3.2 MVCC

MVCC是针对读数据的方案，读不加锁。MVCC基于以下结构

- 隐藏列，每条记录都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等
- 基于undo log的版本链，每条记录包含了执行undo log的指针，每条undo log也会指向更早版本的undo log，从而形成一条版本链
- ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。

**判断可见性**

- low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id。如果数据的事务id大于等于low_limit_id，则对该ReadView不可见。
- up_limit_id：表示生成ReadView时当前系统中活跃的读写事务中最小的事务id。如果数据的事务id小于up_limit_id，则对该ReadView可见。
- rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。如果数据的事务id在low_limit_id和up_limit_id之间，则需要判断事务id是否在rw_trx_ids中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见；如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。

在RC隔离级别下

- **每条 SELECT 语句都创建新的 Read View**
- 保证读到**最新已提交**的数据

在RR隔离级别下

- **Read View 在事务开始时创建，直到事务结束**
- 保证事务内多次读取看到**相同的数据快照**







