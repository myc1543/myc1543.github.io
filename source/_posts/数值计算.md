---
title: 数值计算
typora-root-url: 数值计算
date: 2026-01-15 19:45:49
tags: [Java]
categories: [Java]
description: 不想写简介了。。。好吧，这篇文章是关于数值计算的，包括精度、舍入和溢出问题
---

## 1. 浮点数

### 1.1浮点数计算

学过计算机组成原理的同学都知道，在程序中，我们使用二进制并不能准确地表示一个数。以0.1为例，0.1的二进制表示为0.0 0011 0011 0011…，再转化为十进制，就变成了0.1000000000000000055511151231257827021181583404541015625。

```
System.out.println(0.1 + 0.2);
// 输出结果：0.30000000000000004
```

所以我们在使用浮点数时，需要注意可能带来的误差。

### 1.2 浮点数格式化

````
 double num1 = 3.35;
 float num2 = 3.35f;
 System.out.println(String.format("%.1f", num1)); // 输出3.4
 System.out.println(String.format("%.1f", num2)); // 输出3.3
````

这就是由精度问题和舍入方式共同导致的，double和float的3.35其实相当于3.350xxx和3.349xxx：

```
3.350000000000000088817841970012523233890533447265625
3.349999904632568359375
```

String.format采用四舍五入的方式进行舍入，取1位小数，double的3.350四舍五入为3.4，而float的3.349四舍五入为3.3。



## 2.BigDecimal

涉及到精确计算时，我们常常使用decimal来代替浮点数。但是使用浮点数也有一些注意事项



### 2.1 使用字符串的构造方法来初始化BigDecimal

---

#### 使用浮点数来初始化BigDecimal

```
System.out.println(new BigDecimal(0.1).add(new BigDecimal(0.2)));
// 输出结果 0.3000000000000000166533453693773481063544750213623046875
```

对比直接使用浮点数做运算，使用BigDecimal，仅仅是提高了精度，并没有解决根本问题。



####  使用字符串来初始化BigDecimal

```
System.out.println(new BigDecimal("0.1").add(new BigDecimal("0.2")));
// 输出结果 0.3
```



#### double转为字符串，初始化BigDecimal

```
System.out.println(new BigDecimal("3.1").multiply(new BigDecimal(Double.toString(100))));
// 输出结果 310.00
```

BigDecimal有scale和precision两个概念

- scale:小数点右边的位数
- precision:有效数字的长度

**对于BigDecimal乘法操作，返回值的scale是两个数的scale相加**

new BigDecimal("3.1")得到的为3.1，new BigDecimal(Double.toString(100))得到的为100.0，所以相乘得到310.00



### 2.2 浮点数的字符串格式化通过BigDecimal来进行

根据对浮点数的测试，在进行格式化的时候会有精度问题，使用BigDecimal可以避免这个问题

```
BigDecimal num1 = new BigDecimal("3.35");
BigDecimal num2 = num1.setScale(1, BigDecimal.ROUND_DOWN);
System.out.println(num2); // 3.3
BigDecimal num3 = num1.setScale(1, BigDecimal.ROUND_HALF_UP);
System.out.println(num3); // 3.4
```



### 2.3 BigDecimal判等

BigDecimal的判等会同时判断scale和value

````
System.out.println(new BigDecimal("1").equals(new BigDecimal("1.0"))); // false
````

可以通过compareTo方法只比较数值部分

```
System.out.println(new BigDecimal("1").compareTo(new BigDecimal("1.0")) == 0); // true
```



#### HashSet 和 HashMap问题

```
Set hashSet1 = new HashSet<>();
hashSet1.add(new BigDecimal("1.0"));
System.out.println(hashSet1.contains(new BigDecimal("1")));// false
```

有两个解决方法

- 使用TreeSet替换HashSet，TreeSet不使用hashCode方法，也不使用equals，而是使用compareTo
- 把BigDecimal存入HashSet或HashMap前，先使用stripTrailingZeros方法去掉尾部的零，比较的时候也去掉尾部的0，确保value相同的BigDecimal，scale也是一致的

```
Set hashSet2 = new HashSet<>();
hashSet2.add(new BigDecimal("1.0").stripTrailingZeros());
System.out.println(hashSet2.contains(new BigDecimal("1.000").stripTrailingZeros()));// true
```



## 3. 溢出问题

和小数类似，由于数值是二进制表示，当数值超过了可表示的最大值，就会变成最小值

```
long l = Long.MAX_VALUE;
System.out.println(l + 1);
System.out.println(l + 1 == Long.MIN_VALUE);
--------------------------------------------
输出结果
-9223372036854775808
true

```

当发生溢出时，没有任何异常，所以难以感知到，要解决这个问题，有以下两种方法

### 3.1 Exact方法

使用Math类的addExact、subtractExact等xxExact方法进行数值运算，这些方法可以在数值溢出时主动抛出异常

```
try {
            long l = Long.MAX_VALUE;
            System.out.println(Math.addExact(l, 1));
        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }
```

**结果**

```
java.lang.ArithmeticException: long overflow
	at java.lang.Math.addExact(Math.java:809)
```



### 3.2 使用大数类BigInteger

如果希望把计算结果转换一个Long变量的话，可以使用BigInteger的longValueExact方法，在转换出现溢出时，同样会抛出ArithmeticException：

```
BigInteger i = new BigInteger(String.valueOf(Long.MAX_VALUE));
System.out.println(i.add(BigInteger.ONE).toString());

try {
    long l = i.add(BigInteger.ONE).longValueExact();
} catch (Exception ex) {
    ex.printStackTrace();
}
```

**结果**

```
9223372036854775808
java.lang.ArithmeticException: BigInteger out of long range
	at java.math.BigInteger.longValueExact(BigInteger.java:4632)
```

