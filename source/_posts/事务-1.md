---
title: 事务(1)
typora-root-url: 事务(1)
date: 2026-01-16 16:39:55
tags: [MySQL]
categories: [MySQL]
description: MySQL中的事务
---

最近在看事务相关的问题，所以打算把事务写成一个专题，从存储层的事务到应用层的事务。

## 1.什么是事务？

事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。简单来说就是，多条sql是一个整体，要么全都执行成功，要么全部执行失败。

#### 例子

某人要在商店使购买100元的东西，当中至少包括两个操作：

1. 该人账户减少100元
2. 商店账户增加100元

事务就是要确保以上两个操作（整个“事务”）都能完成，或一起取消；否则就会出现100元平白消失或出现的情况

## 2.事务的特性-ACID

事务应该拥有以下四个特性

- **原子性（Atomicity）**：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
- **一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。*一致状态*的含义是数据库中的数据应满足完整性约束。
- **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- **持久性（Durability）**：已被提交的事务对数据库的修改应该永久保存在数据库中。

只有保证了AID，才能保证一致性。

![AID->C](AID->C.png)



### 

## 3.验证ACID

现在我们有一张账户表，里面记录着余额。

````
CREATE TABLE account (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    balance INT
) ENGINE=InnoDB;
````

有A和B两个人，账户都为100

```
INSERT INTO account(name, balance) VALUES ('A', 100), ('B', 100);
```



### 3.1 原子性

#### 执行成功

**转账前**

```
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |     100 |
|  2 | B    |     100 |
+----+------+---------+
```



A向B转账10元

```
-- 开启事务
start transaction;
UPDATE account SET balance = balance - 10 WHERE name = 'A';
UPDATE account SET balance = balance + 10 WHERE name = 'B';
-- 提交事务
commit;
```

转账成功后

```
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |      90 |
|  2 | B    |     110 |
+----+------+---------+
```



#### 执行失败

**转账前**

```
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |      90 |
|  2 | B    |     110 |
+----+------+---------+
```



A向B转账10元，失败

```
-- 开启事务
start transaction;
UPDATE account SET balance = balance - 10 WHERE name = 'A';
UPDATE account SET balance = balance + 10 WHERE name = 'B';
-- 更新不存在的数据，发生错误
UPDATE account SET unknown = 1; 
-- 回滚事务
rollback;
```

**转账后**

```
mysql> select * from account;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |      90 |
|  2 | B    |     110 |
+----+------+---------+
```



### 3.2 持久性

事务提交后，修改永久保存到数据库，即使系统崩溃也不丢失。



A的账户到账100元

```
-- 开启事务
start transaction;
UPDATE account SET balance = balance + 100 WHERE name = 'A';
-- 提交事务
commit;
```

**到账前**

```
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |      90 |
|  2 | B    |     110 |
+----+------+---------+
```

**到账后**

```
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |     190 |
|  2 | B    |     110 |
+----+------+---------+
```

**模拟故障**

在事务提交后立即关闭数据库，重启后验证数据是否保留



```
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  1 | A    |     190 |
|  2 | B    |     110 |
+----+------+---------+
```



### 3.3 隔离性

MySQL 提供四种事务隔离级别：读未提交、读已提交、可重复读（默认）、串行化。不同的食事务隔离级别，是在数据一致性和速度之间的权衡。



#### (1)读未提交 Read Uncommitted

允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

**脏读**

能够读取到未提交的事务的执行结果

```
-- 会话1
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION; -- 开启事务
UPDATE account SET balance = balance + 100 WHERE name = 'A';
-- 不执行COMMIT，事务未提交

```

```
-- 会话2
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT balance FROM account WHERE name = 'A'; 
```

| 会话1(初始数据)                  | 会话1(会话2开启事务后)                                  |
| -------------------------------- | ------------------------------------------------------- |
| ![](image-20260117213843383.png) | ![image-20260117213855509](image-20260117213855509.png) |

可以看到，会话2中查询的结果是会话1中sql执行的结果。会话1的事务还没有提交，其他事务就可以读取到结果，造成了脏读。



#### (2)读已提交 READ-COMMITTED

读已提交隔离级别，解决了脏读的问题，但没有解决可重复读(同一个事务内前后读取的结果不同)。

```
-- 会话1
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT balance FROM account WHERE name = 'A'; 

```

```
-- 会话2
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
UPDATE account SET balance = 2000 WHERE name = 'A';
COMMIT; -- 提交事务
```

```
-- 会话1
SELECT balance FROM account WHERE name = 'A';
COMMIT;
```

| 初始数据                                                |
| ------------------------------------------------------- |
| ![image-20260117214247313](image-20260117214247313.png) |


| 会话2提交事务前                                         | 会话2提交事务后                                         |
| ------------------------------------------------------- | ------------------------------------------------------- |
| ![image-20260117214729349](image-20260117214729349.png) | ![image-20260117214823134](image-20260117214823134.png) |

可以看到，读未提交解决了脏读的问题，没有被会话2未提交的事务影响。
但是可以发现，在会话1的同一个事务中，读取同一条数据的结果不同，这就是不可重复读。





#### (3)可重复读 REPEATABLE-READ

可重复读，针对的是读已提交的不可重复读。在同一个事务内读取的结果一致。

```
-- 会话1
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT balance FROM account WHERE name = 'A'; 

```

```
-- 会话2
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
UPDATE account SET balance = 2000 WHERE name = 'A';
COMMIT; -- 提交事务
```

```
-- 会话1
SELECT balance FROM account WHERE name = 'A';
COMMIT;
```


| 初始数据                                                | 会话2提交事务后                                         |
| ------------------------------------------------------- | ------------------------------------------------------- |
| ![image-20260117215635667](image-20260117215635667.png) | ![image-20260117215755132](image-20260117215755132.png) |

可重复读，同一个事务内读取到的结果一致。

可重复读没有解决幻读的问题(读取到并不存在的数据)。在MySQL中，通过MVCC和锁，能够解决大部分幻读的问题。



####  可重复读 - 幻读

```
-- 会话1
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM account; 
```

````
-- 会话2
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
INSERT INTO account values(null,'D',200);
````

```
-- 会话1
SELECT * FROM account; 
UPDATE account SET balance = 2000 WHERE name = 'D';
commit;
```



| 会话2事务提交前                                         | 会话2事务提交后                                         |
| ------------------------------------------------------- | ------------------------------------------------------- |
| ![image-20260117221109954](image-20260117221109954.png) | ![image-20260117222630040](image-20260117222630040.png) |

可以发现，在会话1中，竟然更新了不存在的数据。提交事务后，确实name = ‘D'的数据确实被修改了

#### (4)可串行化 SERIALIZABLE

所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰

```
-- 会话1
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM account;
```

```
-- 会话2
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
INSERT INTO account values(null,'F',400);
```

| 会话1事务提交前                                         | 会话1事务提交后                                         |
| ------------------------------------------------------- | ------------------------------------------------------- |
| ![image-20260117223050140](image-20260117223050140.png) | ![image-20260117223107072](image-20260117223107072.png) |

在会话1提交事务前，会话2无法插入数据。直到事务提交后，才能插入。



### 3.4 一致性

一致性是由上面三种特性共同实现，所以在这里就不进行演示。
