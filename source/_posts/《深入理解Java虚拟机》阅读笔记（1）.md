---
title: 《深入理解Java虚拟机》阅读笔记（1）
typora-root-url: 《深入理解Java虚拟机》阅读笔记（1）
date: 2025-11-24 16:30:44
tags: [Java]
categories: [技术,Java]
description: 《深入理解Java虚拟机》阅读笔记，本篇文章主要是关于Java内存区域。
---

## 1.第一章“走进“Java”

**Java的优势之JVM**

- 虚拟机层面屏蔽技术的复杂性和操作系统的差异性



## 2.第二章“Java内存区域与内存溢出异常”

### 2.1 运行时数据区域

![JVM内存区域](image-20251124231738862.png)

#### 2.1.1程序计数器

程序计数器是当前线程所执行的字节码的行号指示器(唯一不会出现OOM的区域)

因为Java是多线程执行的，每个处理器在一个时间内只会执行一条线程内的指令，所以每条线程都要有单独的程序计数器，为了线程切换后能恢复到正确的执行位置。



#### 2.1.2 Java虚拟机栈

虚拟机栈是线程私有的，生命周期和线程相同。描述的是Java方法执行的线程内存模型。每个方法被执行的时候，会同步创建栈帧。

- 栈帧

  - 局部变量表：编译器可知的基本数据类型、对象引用、返回地址

  - 操作数栈：用于暂存计算的操作数和结果

  - 动态链接：符号引用(字符串)转化内直接引用(指针)

  - 方法出口

    ​													

#### 2.1.3 本地方法栈

本地方法栈执为虚拟机使用到的本地方法服务



#### 2.1.4 Java堆

堆是虚拟机锁管理的内存中最大的一块，被所有线程共享。在虚拟机启动时创建，存放对象实例(所有还是大部分？)

从内存分配的角度来看，堆中还可以划分出线程私有的分配缓冲区。

**改变Java堆的大小**

- -Xmx
- -Xms



**字符串常量池**

编译器可确定的字符串常量自动入池，运行时生成的字符串需要通过intern()手动入池



#### 2.1.5 方法区

方法区是各个线程共享的内存区域，存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。



#### 2.1.6 运行时常量池 

运行时常量池是方法区的一部分，存放编译器生成的各种字面量与符号引用

String.intern

####  2.2.7  直接内存

直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

### 2.3HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建

当虚拟机遇到new字节码指令时，首先回去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析、初始化过，如果没有，先执行类的加载。

- 为新生对象分配内存，根据Java堆的内存是否规整，选择指针碰撞或空闲列表的方式分配内存
  - 针对并发问题，有CAS和本地线程分配缓冲
- 内存分配完成后，必须将分配到的内存空间初始化为零值
- 对对象进行必要的设置
- 执行构造函数，对对象进行初始化



#### 2.3.2 对象的内存布局

对象在HotSpot虚拟机中的存储布局可以分为三个部分：对象头、实例数据、对齐填充。

*** 对象头***

- 对象自身的运行时数据(Mark Word)
  - 哈希码
  - GC分代年龄
  - 锁状态标志
  - 线程持有的锁
  - 偏向线程ID
- 类型指针
  - 对象指向它的类型元数据的指针

***实例数据***

- 程序代码中所定义的各种类型的字段内容

*** 对齐填充***

- 占位符，符合对象的起始地址是8字节的整数倍



#### 2.3.3 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象。reference是一个指向对象的引用，通过引用去访问对象的方式主要有句柄和直接指针两种

*** 句柄***‘

- 堆中内存划分出一块作为句柄池，reference中存储的是对象的句柄地址，句柄在包含对象实例数据和对象类型数据各自具体的地址信息。

***直接指针***

存储的是对象地址



### 2.4 OOM

#### 2.4.1 堆溢出

对象太多，总容量触及最大堆的容量限制后就会产生内存溢出异常。

#### 2.4.2  栈溢出

栈溢出的本质是新的栈帧内存无法分配的时候，导致OOM。

有两种情况

- 栈帧太大
- 虚拟机栈容量太小





