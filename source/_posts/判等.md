---
title: 判等
typora-root-url: 判等
date: 2026-01-15 10:25:47
tags: [Java]
categories: [Java]
description: 本篇文章主要讨论判断相等的问题，在Java中，主要是对基本类型的对象判等。
---

## 1.判等的工具

在Java中，有两种方式来判断是否相等：==和equals。

==是操作符而equals是方法。

### 1.1 ==

==比较的是直接值。对于基本类型而言，基本类型的值就是直接值。对于引用对象而言，直接值是指针。所以对于包装类型的数值，一般不建议使用==。



### 1.2 equals

equals是Object类的equals方法，实际上比较的是对象引用

```
public boolean equals(Object obj){
return (this == obj);
}
```

所以在自定义类型中，如果不实现equals方法，默认是比较引用，用==判断。

**举个例子**

```
public class Point {
    private int x;
    private int y;
    public Point(int x, int y){
        this.x = x;
        this.y = y;
    }

}
```

```
 Point p1 = new Point(1,2);
 Point p2 = new Point(1,2);
 System.out.println(p1.equals(p2));  // 结果为false
```



**重写equals方法**

```
    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Point point = (Point) o;
        return x == point.x && y == point.y;
    }
```

由于重写的equals方法入参是Object，所以这里需要注意

- 对入参进行判空
- 对入参的类型进行判断

### 1.3 hashCode

由于Set是无重复的集合，所以在Set判断是否有某个元素时也会有判等的问题。Set使用hashCode进行判等。在不重写hashCode方法前，默认使用Object超类的实现，使用hashCode来判断。

```
  Set<Point> set = new HashSet<>();
  Point p1 = new Point(1,2);
  Point p2 = new Point(1,2);
  set.add(p1);
  System.out.println(set.contains(p2)); // 返回false
```

重写hashCode方法，直接使用Objects.hash方法即可

```
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
```



## 2.Lombok

Lombok的@Data会实现equals和hashCode方法，但是存在继承关系时，@EqualsAndHashCode方法默认实现没有使用父类属性。

可以手动设置callSuper开关为true，来覆盖这种默认行为

```
@EqualsAndHashCode(callSuper = true)
```



## 3.常量池

### 3.1 包装类型常量池

通过valueOf创建的包装对象，是可以通过缓存来获取对象的。

| 基本数据类型 | 包装类型  | 缓存范围   |
| ------------ | --------- | ---------- |
| byte         | Byte      | -128 ~ 127 |
| short        | Short     | -128 ~ 127 |
| int          | Integer   | -128 ~ 127 |
| long         | Long      | -128 ~ 127 |
| char         | Character | 0 ~ 127    |
| boolean      | Boolean   | true,false |
| float        | Float     | 无         |
| double       | Double    | 无         |



**举个例子**

```
public static void main(String[] args) {
    Integer x = 12;
    Integer y = 12;
    Integer a = 143;
    Integer b = 143;
    Integer c = new Integer(1);
    Integer d = new Integer(1);
    System.out.println(x == y); // true
    System.out.println(a == b); // false
    System.out.println(c == d); // false
    
}
```

- Integer x  =  12；实际上是Integer x = Integer.valueOf(12)，会在缓存池中查找对象，x和y使用的是同一个对象，所以返回true。
- a和b超出了-128 - 127的范围
- c和d是new出来的对象，不会查找缓存池

#### Integer改变常量池范围

修改JVM参数

```
-XX:AutoBoxCacheMax=1000
```



### 3.2 字符串

字符串也实现了常量池。一下对象会放到字符串常量池

- 双引号申明的String对象
- String提供的intern方法

```
public static void main(String[] args) {
        String s1 = "test";
        String s2 = "test";
        String s3 = new String("test1");
        String s4 = new String("test1");
        String s5 = new String("test2").intern();
        String s6 = new String("test2").intern();
        System.out.println(s1 == s2); // true
        System.out.println(s3 == s4); // false
        System.out.println(s5 == s6); // true
    }
```



#### 字符串常量池的本质

字符串常量池是一个固定容量的Map，如果容量太小，字符串太多，每一个桶中的字符串数量太多，查找会很慢。

设置JVM参数-XX:StringTableSize，指定更多的桶
