<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中的排序</title>
    <url>/2026/01/13/Java%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="1-排序的对象"><a href="#1-排序的对象" class="headerlink" title="1.排序的对象"></a>1.排序的对象</h2><p>在Java中，排序的对象主要有两类：数组和集合。</p>
<ul>
<li>数组<ul>
<li>基本类型数组</li>
<li>对象数组</li>
</ul>
</li>
<li>集合<ul>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ul>
</li>
</ul>
<h2 id="2-数组排序"><a href="#2-数组排序" class="headerlink" title="2.数组排序"></a>2.数组排序</h2><p>对数组排序，使用<code>Arrays.sort()</code>方法，默认升序，降序排序可考虑将数组反转。</p>
<h3 id="2-1-基本类型数组"><a href="#2-1-基本类型数组" class="headerlink" title="2.1 基本类型数组"></a>2.1 基本类型数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] array = new int[]&#123;154,562,105,4,46,7&#125;;</span><br><span class="line">       System.out.println(&quot;排序前:&quot; + Arrays.toString(array));</span><br><span class="line">       Arrays.sort(array);</span><br><span class="line">       System.out.println(&quot;排序后:&quot; + Arrays.toString(array));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2对象数组"><a href="#2-2对象数组" class="headerlink" title="2.2对象数组"></a>2.2对象数组</h3><p><strong>排序规则</strong></p>
<p>compare(o1, o2): </p>
<ul>
<li>返回负数: o1 &lt; o2 (o1 排在前面) -</li>
<li>返回 0:   o1 &#x3D;&#x3D; o2 </li>
<li>返回正数: o1 &gt; o2 (o2 排在前面)</li>
</ul>
<p>在这里，以User对象来进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public User(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name + &quot;:&quot; + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-2-1-实现Comparable接口"><a href="#2-2-1-实现Comparable接口" class="headerlink" title="2.2.1 实现Comparable接口"></a>2.2.1 实现Comparable接口</h4><p>需要排序的对象，需要实现Comparable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User implements Comparable&lt;User&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public User(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(User other) &#123;</span><br><span class="line">        return this.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name + &quot;:&quot; + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 创建测试数据</span><br><span class="line">        User[] users = &#123;</span><br><span class="line">            new User(&quot;张三&quot;, 25),</span><br><span class="line">            new User(&quot;李四&quot;, 20),</span><br><span class="line">            new User(&quot;王五&quot;, 30),</span><br><span class="line">            new User(&quot;赵六&quot;, 22),</span><br><span class="line">            new User(&quot;孙七&quot;, 28),</span><br><span class="line">            new User(&quot;周八&quot;, 18),</span><br><span class="line">            new User(&quot;吴九&quot;, 35),</span><br><span class="line">            new User(&quot;郑十&quot;, 26)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前:&quot; + Arrays.toString(users));</span><br><span class="line"></span><br><span class="line">        // 使用 Comparable 排序（按年龄升序）</span><br><span class="line">        Arrays.sort(users);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n排序后（按年龄升序）:&quot; + Arrays.toString(users));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-Comparator接口"><a href="#2-2-2-Comparator接口" class="headerlink" title="2.2.2 Comparator接口"></a>2.2.2 Comparator接口</h4><p>与实现Comparable接口不同，Comparator排序，是自定义了排序规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       // 创建测试数据</span><br><span class="line">       User[] users = &#123;</span><br><span class="line">           new User(&quot;张三&quot;, 25),</span><br><span class="line">           new User(&quot;李四&quot;, 20),</span><br><span class="line">           new User(&quot;王五&quot;, 30),</span><br><span class="line">           new User(&quot;赵六&quot;, 22),</span><br><span class="line">           new User(&quot;孙七&quot;, 28),</span><br><span class="line">           new User(&quot;周八&quot;, 18),</span><br><span class="line">           new User(&quot;吴九&quot;, 35),</span><br><span class="line">           new User(&quot;郑十&quot;, 26)</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;排序前:&quot; + Arrays.toString(users));</span><br><span class="line"></span><br><span class="line">       // 使用 Comparable 排序（按年龄升序）</span><br><span class="line">       Arrays.sort(users, new Comparator&lt;User&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(User o1, User o2) &#123;</span><br><span class="line">               return o1.age - o2.age;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;\n排序后（按年龄升序）:&quot; + Arrays.toString(users));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以简化一些，使用Lambda 表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 Comparable 排序（按年龄升序）</span><br><span class="line">       Arrays.sort(users, (p,q) -&gt; p.age - q.age);</span><br></pre></td></tr></table></figure>





<h4 id="2-2-3-pair排序"><a href="#2-2-3-pair排序" class="headerlink" title="2.2.3 pair排序"></a>2.2.3 pair排序</h4><p>常见于数组排序，举个例子,使用大小为2的数组表示一个区间，对区间数组排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[][] intervals = &#123;</span><br><span class="line">           &#123;1, 5&#125;,</span><br><span class="line">           &#123;3, 7&#125;,</span><br><span class="line">           &#123;1, 3&#125;,   // 起点和第一个区间相同</span><br><span class="line">           &#123;3, 4&#125;,   // 起点和第二个区间相同</span><br><span class="line">           &#123;2, 6&#125;,</span><br><span class="line">           &#123;1, 8&#125;    // 起点和第一、三个区间相同</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure>

<p>排序方法和对象类似，以起点为准排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);</span><br></pre></td></tr></table></figure>

<p>还有一种可能就是，起点相同的情况下，看终点的位置，也就是多字段排序</p>
<ul>
<li>手动排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">           if (a[0] != b[0]) &#123;</span><br><span class="line">               return a[0] - b[0];  // 起点不同，按起点排序</span><br><span class="line">           &#125;</span><br><span class="line">           return a[1] - b[1];      // 起点相同，按终点排序</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>链式调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(intervals, Comparator</span><br><span class="line">        .comparingInt((int[] a) -&gt; a[0])  // 先按起点</span><br><span class="line">        .thenComparingInt(a -&gt; a[1]));    // 再按终点</span><br></pre></td></tr></table></figure>



<h2 id="3-集合排序"><a href="#3-集合排序" class="headerlink" title="3.集合排序"></a>3.集合排序</h2><p>集合排序和数组排序类似，只不过集合排序使用的是<code>Collections.sort</code></p>
<h3 id="3-1-List"><a href="#3-1-List" class="headerlink" title="3.1 List"></a>3.1 List</h3><h3 id="3-1-1-实现Comparable接口"><a href="#3-1-1-实现Comparable接口" class="headerlink" title="3.1.1 实现Comparable接口"></a>3.1.1 实现Comparable接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">        users.add(new User(&quot;张三&quot;, 25));</span><br><span class="line">        users.add(new User(&quot;李四&quot;, 30));</span><br><span class="line">        users.add(new User(&quot;王五&quot;, 25));</span><br><span class="line">        users.add(new User(&quot;赵六&quot;, 25));</span><br><span class="line">        users.add(new User(&quot;孙七&quot;, 30));</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        Collections.sort(users);</span><br><span class="line">        System.out.println(users);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-1-2-实现Comparator"><a href="#3-1-2-实现Comparator" class="headerlink" title="3.1.2 实现Comparator"></a>3.1.2 实现Comparator</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(users, new Comparator&lt;User&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public int compare(User o1, User o2) &#123;</span><br><span class="line">              return o1.age - o2.age;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式简化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(users, (u1,u2) -&gt; u1.age - u2.age);</span><br></pre></td></tr></table></figure>



<h4 id="3-1-3-多字段排序"><a href="#3-1-3-多字段排序" class="headerlink" title="3.1.3 多字段排序"></a>3.1.3 多字段排序</h4><p>先按年龄排序，如果年龄相同，按姓名排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(users, (u1,u2) -&gt; &#123;</span><br><span class="line">            if(u1.age != u2.age)&#123;</span><br><span class="line">                return u1.age - u2.age;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return u1.name.compareTo(u2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-通过List的sort方法"><a href="#3-1-4-通过List的sort方法" class="headerlink" title="3.1.4 通过List的sort方法"></a>3.1.4 通过List的sort方法</h4><p>以上通过Collections.sort排序的集合，都可以通过List.sort来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">users.sort((u1,u2) -&gt; &#123;</span><br><span class="line">            if(u1.age != u2.age)&#123;</span><br><span class="line">                return u1.age - u2.age;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return u1.name.compareTo(u2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>



<h3 id="3-2-Map按key排序"><a href="#3-2-Map按key排序" class="headerlink" title="3.2 Map按key排序"></a>3.2 Map按key排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 按 Key 排序 - 用 TreeMap</span><br><span class="line">Map&lt;K, V&gt; treeMap = new TreeMap&lt;&gt;(hashMap);</span><br></pre></td></tr></table></figure>



<h3 id="3-3-Map按value排序"><a href="#3-3-Map按value排序" class="headerlink" title="3.3 Map按value排序"></a>3.3 Map按value排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 按 Value 排序 - 用 Stream</span><br><span class="line">Map&lt;K, V&gt; sorted = map.entrySet().stream()</span><br><span class="line">    .sorted(Map.Entry.comparingByValue())</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        Map.Entry::getKey,</span><br><span class="line">        Map.Entry::getValue,</span><br><span class="line">        (e1, e2) -&gt; e1,</span><br><span class="line">        LinkedHashMap::new</span><br><span class="line">    ));</span><br></pre></td></tr></table></figure>



<h3 id="3-4-优先队列"><a href="#3-4-优先队列" class="headerlink" title="3.4 优先队列"></a>3.4 优先队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 最小堆</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 最大堆</span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder())</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>AI学习</title>
    <url>/2025/12/28/AI%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>2025年，AI的热度越来越火，许多公司的业务都在朝大模型应用发展，校招面试和社招面试也会提问大模型相关的知识，对于后端选手来说，学习AI相关的知识是必然的。</p>
<h2 id="1-术语解释"><a href="#1-术语解释" class="headerlink" title="1.术语解释"></a>1.术语解释</h2><ul>
<li><p>AI：Artificial Intelligence的缩写，指“人工智能”，人工智能是指模拟人类智能的计算机系统或软件，使其能够执行诸如学习、推理、问题解决、感知、语言理解等复杂任务。</p>
</li>
<li><p>生成式AI：是一种人工智能技术，能够自动生成新的内容，如文本、图像、音频和视频等。与传统的AI不同，生成式AI不仅能分析和理解数据，还能基于其学习到的信息创造出新的内容。</p>
</li>
<li><p>AIGC：AI Generated Content的缩写，意指由人工智能生成的内容。在算法和数码内容制作领域，AIGC 涉及使用人工智能技术生成各种形式的内容，比如文字、图像、视频、音乐等。</p>
</li>
<li><p>NLP：Natural Language Processing的缩写，指“自然语言处理”，自然语言处理是人工智能的一个子领域，主要研究计算机如何理解、解释和生成人类语言。NLP技术包括文本分析、语言生成、机器翻译、情感分析、对话系统等。</p>
</li>
<li><p>LLM：Large Language Model的缩写，指“大语言模型”，这类模型是基于机器学习和深度学习技术，特别是自然语言处理（NLP）中的一种技术。大语言模型通过大量的文本数据进行训练，以生成、理解和处理自然语言。一些著名的 LLM 示例包括 OpenAI 的 GPT（Generative Pre-trained Transformer）系列模型，如 GPT-3 和 GPT-4</p>
</li>
<li><p>RAG：Retrieval-Augmented Generation的缩写，指“检索增强生成”，这是一个跨越检索和生成任务的框架，通过先从数据库或文档集合中检索到相关信息，然后利用生成模型（如Transformer模型）来生成最终的输出。目前在技术发展趋势和应用落地上，RAG是工程同学较为值得探索的领域。</p>
</li>
<li><p>Agent：中文叫智能体，一个能独立执行任务和做出决策的实体，在人工智能中，Agent可以是一个机器人，一个虚拟助手，或是一个智能软件系统，它能够通过学习和推理来完成复杂任务。在多Agent系统中，多个独立的Agents相互协作或竞争，以共同解决问题或完成任务。</p>
</li>
<li><p>GPT：Generative Pre-trained Transformer的缩写，指“生成式预训练变换器”，GPT 模型利用大量文本数据进行预训练，然后可以通过微调来执行特定任务，例如语言生成、回答问题、翻译、文本摘要等。</p>
</li>
<li><p>chatGPT：由 OpenAI 开发的一种基于 GPT（生成预训练变换模型）架构的人工智能聊天机器人。它使用自然语言处理技术，能够理解并生成类似人类的文本回复。可以看做是一种Agent。</p>
</li>
<li><p>Prompt：指的是提供给模型的一段初始文本，用于引导模型生成后续的内容。</p>
</li>
<li><p>Embedding：中文叫嵌入，是一种将高维数据映射到低维空间的技术，但仍尽可能保留原数据的特征和结构。嵌入技术通常用于处理和表示复杂的数据如文本、图像、音乐以及其他高维度的数据类型。</p>
</li>
</ul>
<h2 id="2-LLM"><a href="#2-LLM" class="headerlink" title="2.LLM"></a>2.LLM</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><strong>大型语言模型</strong></a>（英语：large language model，LLM），也称<strong>大语言模型</strong>，简称<strong>大模型</strong>，是一种基于<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">人工神经网络</a>的<a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B">语言模型</a>。其名称中的“大型”指模型具有庞大的参数量（通常在数十亿至数万亿级别，如GPT-3含1750亿参数）以及巨大的训练数据规模。大语言模型通常采用<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">自监督机器学习</a>方法，从而能够基于海量无标注的文本进行训练。大语言模型专为<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">自然语言处理</a>任务而设计，尤其适用于<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90">语言生成</a>。</p>
<h3 id="2-1-大模型的应用"><a href="#2-1-大模型的应用" class="headerlink" title="2.1 大模型的应用"></a>2.1 大模型的应用</h3><p><img src="/2025/12/28/AI%E5%AD%A6%E4%B9%A0/640"></p>
<p>一个典型的大模型应用架构如上图所示，其实和我们平时开发的应用没什么两样。我们平时开发应用，也是处理用户请求，然后调用其它服务实现具体功能。在这个图中，大模型也就是一个普通的下游服务。</p>
<h4 id="2-1-1-联网搜索"><a href="#2-1-1-联网搜索" class="headerlink" title="2.1.1  联网搜索"></a>2.1.1  联网搜索</h4><p>大模型的回答是基于训练的数据，如果提问的内容不在训练的知识范围内，那么大模型只能进行推理，自身没有能力获取外界的知识。联网搜索就是把互联网的内容提供给大模型，让大模型能够参考搜索的结果，给出回答。</p>
<p><img src="/2025/12/28/AI%E5%AD%A6%E4%B9%A0/640"></p>
<h4 id="2-1-2-Prompt-Engineering"><a href="#2-1-2-Prompt-Engineering" class="headerlink" title="2.1.2  Prompt Engineering"></a>2.1.2  Prompt Engineering</h4><p>提示词工程（Prompt Engineering）是一种在人工智能和自然语言处理领域中开发和设计提示词（Prompts）以引导大型语言模型（例如GPT-3等）产生特定输出的方法。通过精心构建和优化提示词，用户可以更有效地获得所需的答案、生成文本或执行其他自然语言处理任务。</p>
<p>提示词可以从大模型中获取大量结果，但是这个结果不一定是期望的结果，所以可以优化提示词，提供更多的信息以及完善度，得到质量更高的结果</p>
<p><strong>举个例子</strong></p>
<p>比如我们想完成对句子的续写：天空是？</p>
<ul>
<li>不添加提示词直接询问</li>
</ul>
<p><img src="/2025/12/28/AI%E5%AD%A6%E4%B9%A0/image-20251228213141341.png" alt="image-20251228213141341"></p>
<p>结果并不是我们想要的</p>
<ul>
<li>添加提示词</li>
</ul>
<p><img src="/2025/12/28/AI%E5%AD%A6%E4%B9%A0/image-20251228213304892.png" alt="image-20251228213304892"></p>
<p>这里明确告诉大模型，我们需要对句子进行续写，生成的质量就比刚才高很多。</p>
<h4 id="2-1-3-提示词要素"><a href="#2-1-3-提示词要素" class="headerlink" title="2.1.3 提示词要素"></a>2.1.3 提示词要素</h4><p><strong>指令</strong>：想要模型执行的特定任务或指令。</p>
<p><strong>上下文</strong>：包含外部信息或额外的上下文信息，引导语言模型更好地响应。</p>
<p><strong>输入数据</strong>：用户输入的内容或问题。</p>
<p><strong>输出指示</strong>：指定输出的类型或格式。</p>
<h4 id="2-1-4-设计提示词的技巧"><a href="#2-1-4-设计提示词的技巧" class="headerlink" title="2.1.4 设计提示词的技巧"></a>2.1.4 设计提示词的技巧</h4><ul>
<li>指令<br>使用命令来指示模型执行各种简单任务，例如“写入”、“分类”、“总结”、“翻译”、“排序”等，从而为各种简单任务设计有效的提示。通常，上下文越具体和跟任务越相关则效果越好</li>
<li>具体性<br>要非常具体地说明你希望模型执行的指令和任务。提示越具描述性和详细，结果越好。特别是当你对生成的结果或风格有要求时，这一点尤为重要。不存在什么特定的词元（tokens）或关键词（tokens）能确定带来更好的结果。更重要的是要有一个具有良好格式和描述性的提示词。事实上，在提示中提供示例对于获得特定格式的期望输出非常有效。<br>在设计提示时，还应注意提示的长度，因为提示的长度是有限制的。想一想你需要多么的具体和详细。包含太多不必要的细节不一定是好的方法。这些细节应该是相关的，并有助于完成手头的任务。这是你需要进行大量实验的事情。我们鼓励大量实验和迭代，以优化适用于你应用的提示。</li>
<li>避免不明确<br>给定上述关于详细描述和改进格式的建议，很容易陷入陷阱：想要在提示上过于聪明，从而可能创造出不明确的描述。通常来说，具体和直接会更好。这里的类比非常类似于有效沟通——越直接，信息传达得越有效。</li>
<li>做什么还是不做什么<br>设计提示时的另一个常见技巧是避免说不要做什么，而应该说要做什么。这样（说要做什么）更加的具体，并且聚焦于（有利于模型生成良好回复的）细节上。</li>
</ul>
<h4 id="2-1-5-提示技术"><a href="#2-1-5-提示技术" class="headerlink" title="2.1.5 提示技术"></a>2.1.5 提示技术</h4><p>提示技术是更高级的技术，完成更加复杂的任务</p>
<ul>
<li>零样本提示</li>
<li>少样本提示</li>
<li>链式思考(COT)提示</li>
<li>生成知识提示</li>
</ul>
<h3 id="2-2-LLM的问题"><a href="#2-2-LLM的问题" class="headerlink" title="2.2 LLM的问题"></a>2.2 LLM的问题</h3><h4 id="2-2-1-知识截止"><a href="#2-2-1-知识截止" class="headerlink" title="2.2.1 知识截止"></a>2.2.1 知识截止</h4><p>LLM 训练不是实时的，而是离线训练好的。在训练过程中，使用的数据都是提前准备的，而且大多数是公开、开源的数据，这就导致了 LLM 训练后具备的知识是有范围的。换句话说，**模型知识仅限于训练数据所涵盖的知识范围，**对于新的知识（比如今天的新闻）或未训练的知识（比如未公开的数据），模型本身不具备这些知识，仅具备推理能力。</p>
<h4 id="2-2-2-幻觉现象"><a href="#2-2-2-幻觉现象" class="headerlink" title="2.2.2 幻觉现象"></a>2.2.2 幻觉现象</h4><p>幻觉现象有多种维度的解释。一方面，LLM 是一个条件概率模型，以前文作为条件的词表概率逐词生成文本，这一机制导致其可能出现**看似逻辑严谨（概率高）但其实缺乏事实依据的生成，<strong>也就是“一本正经地胡说八道”。另一方面，LLM 的训练过程，是</strong>对训练数据的知识进行压缩提炼的过程，但不是无损压缩知识，**边缘知识容易在主流知识冲击下出现扭曲，导致产生了幻觉。</p>
<h2 id="3-RAG"><a href="#3-RAG" class="headerlink" title="3.RAG"></a>3.RAG</h2><p>针对LLM的问题，RAG可以有效解决模型知识截止和幻觉现象。RAG 是检索增强生成（Retrieval-Augmented Generation）的缩写。检索增强生成，是指对大语言模型（LLM）输入进行优化，使其能够在生成响应之前引用训练数据来源之外的知识，作为回答的根据。这是一种经济高效地改进 LLM 输出的方法，让 LLM 保持相关性、准确性和实用性。</p>
<h3 id="3-1-RAG的组成部分"><a href="#3-1-RAG的组成部分" class="headerlink" title="3.1 RAG的组成部分"></a>3.1 RAG的组成部分</h3><ul>
<li>**检索（Retrieval）：**查询外部数据源，例如知识库、向量数据库或者网页搜索API。常见的检索方法有全文检索、向量检索、图检索等。</li>
<li>**生成（Generation）：**将检索信息提供给 LLM，生成回答。</li>
</ul>
<h3 id="3-2-RAG的应用"><a href="#3-2-RAG的应用" class="headerlink" title="3.2 RAG的应用"></a>3.2 RAG的应用</h3><p>具体来说，RAG模型在生成答案之前，会首先从一个大型的文档库或知识库中检索到若干条相关的文档片段。再将这些检索到的片段作为额外的上下文信息，输入到生成模型中，从而生成更为准确和信息丰富的文本。</p>
<p>RAG的工作原理可以分为以下几个步骤：</p>
<p>1.接收请求：首先，系统接收到用户的请求（例如提出一个问题）。</p>
<p>2.信息检索（R)：系统从一个大型文档库中检索出与查询最相关的文档片段。这一步的目标是找到那些可能包含答案或相关信息的文档。</p>
<p>3.生成增强（A）：将检索到的文档片段与原始查询一起输入到大模型（如chatGPT）中，注意使用合适的提示词，比如原始的问题是XXX，检索到的信息是YYY，给大模型的输入应该类似于：请基于YYY回答XXXX。</p>
<p>4.输出生成（G)：大模型基于输入的查询和检索到的文档片段生成最终的文本答案，并返回给用户。</p>
<p>RAG 需要注意两个问题：</p>
<ul>
<li>检索结果 和 解答问题需要参考的资料 越相关，生成结果越准确。</li>
<li>检索出过多的内容，又会引入更多的噪声，影响 LLM 注意力，增加幻觉风险，生成的质量反而降低。</li>
</ul>
<p>为了尽可能准确地找到和原始问题相关的内容，我们需要某种程度上尽可能 <strong>理解原问题的语义。</strong></p>
<h3 id="3-3-向量数据库"><a href="#3-3-向量数据库" class="headerlink" title="3.3 向量数据库"></a>3.3 向量数据库</h3><p>在R阶段，需要理解用户的输入，也就是用户输入的语义。</p>
<p>向量数据库可以解决语义的问题。举个例子，比如“老婆”和“妻子”，这两个词是不同的，但是从语义上来说，它们是相同的。向量数据库使用高维向量来表示一个词的语义。语义越相似的文本，在向量空间中的位置越相近；语义差异越大，在向量空间中的距离越远。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RAG</tag>
      </tags>
  </entry>
  <entry>
    <title>List的坑</title>
    <url>/2026/01/15/List%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="Arrays-asList返回的List不支持增删操作"><a href="#Arrays-asList返回的List不支持增删操作" class="headerlink" title="Arrays.asList返回的List不支持增删操作"></a>Arrays.asList返回的List不支持增删操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1,2,3);</span><br><span class="line">list.add(4);</span><br></pre></td></tr></table></figure>

<p>通过Arrays.asList得到的list插入数据， 此时会发生错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">	at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">	at java.util.AbstractList.add(AbstractList.java:108)</span><br></pre></td></tr></table></figure>



<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements RandomAccess, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>ArrayList不是util包下的ArrayList，而是Arrays的内部类，继承了AbstractList的抽象类，但是没有实现add、remove方法，调用AbstractList的方法。而AbstractList的方法是抛出一个异常。。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu更新镜像源</title>
    <url>/2025/11/23/Ubuntu%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h3 id="1-Ubuntu软件源配置文件"><a href="#1-Ubuntu软件源配置文件" class="headerlink" title="1. Ubuntu软件源配置文件"></a>1. Ubuntu软件源配置文件</h3><figure class="highlight plaintext"><figcaption><span>cd</span><a href="/etc/apt">link</a></figcaption><table><tr><td class="code"><pre><span class="line">sudo cd /etc/apt</span><br></pre></td></tr></table></figure>

<p>Ubuntu的软件源配置文件在<code>/etc/apt</code>的<code>sources.list</code>中</p>
<h3 id="2-备份配置文件"><a href="#2-备份配置文件" class="headerlink" title="2.备份配置文件"></a>2.备份配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp sources.list sources.list.bak</span><br></pre></td></tr></table></figure>

<p>备份一份配置文件，以便以后需要时找回</p>
<h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi sources.list</span><br></pre></td></tr></table></figure>

<p>依次按下<code>g</code> <code>d</code> <code>shift</code> <code>g</code>删除所有内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aliyun</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>复制对应版本的镜像源，我这里是Ubuntu22.04 阿里镜像源，其余版本可自行Google</p>
<p>按下<code>:</code> <code>wq</code> 保存并退出</p>
<h3 id="4-更新软件源"><a href="#4-更新软件源" class="headerlink" title="4.更新软件源"></a>4.更新软件源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<p>更新软件源</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL的安装</title>
    <url>/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本篇文章参考微软的文档</p>
<p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">https://learn.microsoft.com/zh-cn/windows/wsl/install</a></p>
<h2 id="1-安装WSL命令"><a href="#1-安装WSL命令" class="headerlink" title="1. 安装WSL命令"></a>1. 安装WSL命令</h2><h3 id="1-1-管理员身份打开PowerShell"><a href="#1-1-管理员身份打开PowerShell" class="headerlink" title="1.1 管理员身份打开PowerShell"></a>1.1 管理员身份打开PowerShell</h3><p>输入</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/image-20251121223823461.png"></p>
<p>该命令会自动启用WSL相关的组件。接着重启电脑。</p>
<p>或者使用windows功能(启用或关闭Windows功能)，启用<strong>适用于Linux的Windows子系统</strong></p>
<p><img src="/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/image-20251121222954406.png" alt="image-20251121222954406"></p>
<h2 id="2-设置WSL版本为WSL2"><a href="#2-设置WSL版本为WSL2" class="headerlink" title="2. 设置WSL版本为WSL2"></a>2. 设置WSL版本为WSL2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>



<h2 id="3-安装Linux发行版-注意安装位置"><a href="#3-安装Linux发行版-注意安装位置" class="headerlink" title="3.安装Linux发行版(注意安装位置)"></a>3.安装Linux发行版(注意安装位置)</h2><p>建议从<strong>Microsoft Store</strong>安装稳定的Linux发行版，这里以Ubuntu 18.04为例</p>
<h3 id="3-1-安装发行版"><a href="#3-1-安装发行版" class="headerlink" title="3.1 安装发行版"></a>3.1 安装发行版</h3><p><img src="/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/image-20251121223552582.png"></p>
<h3 id="3-2-初始化信息"><a href="#3-2-初始化信息" class="headerlink" title="3.2 初始化信息"></a>3.2 初始化信息</h3><p><img src="/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/image-20251121223934668.png"></p>
<p>输入自己的用户名以及密码</p>
<h2 id="4-检查安装"><a href="#4-检查安装" class="headerlink" title="4. 检查安装"></a>4. 检查安装</h2><h3 id="4-1-查看已安装的发行版及其版本"><a href="#4-1-查看已安装的发行版及其版本" class="headerlink" title="4.1 查看已安装的发行版及其版本"></a>4.1 查看已安装的发行版及其版本</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>



<h3 id="4-2-进入WSL"><a href="#4-2-进入WSL" class="headerlink" title="4.2 进入WSL"></a>4.2 进入WSL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure>

<p>命令行输入bash进入WSL，建议更换终端Hyper</p>
<h2 id="5-WSL的迁移"><a href="#5-WSL的迁移" class="headerlink" title="5. WSL的迁移"></a>5. WSL的迁移</h2><p>如果Linux发行版安装到了C盘，并且C盘空间不足时，可以参考一下操作将其迁移到其他盘</p>
<h3 id="5-1-停止WSL的运行"><a href="#5-1-停止WSL的运行" class="headerlink" title="5.1 停止WSL的运行"></a>5.1 停止WSL的运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>

<p>首先查看WSL的运行状态</p>
<p><img src="/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/image-20251121225104829.png"></p>
<p>如果WSL正在运行，首先终止其运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>

<p>确保处于stopped的状态</p>
<h3 id="5-2-导出-恢复备份"><a href="#5-2-导出-恢复备份" class="headerlink" title="5.2 导出&#x2F;恢复备份"></a>5.2 导出&#x2F;恢复备份</h3><p>在新的盘中创建一个新的目录来存放迁移后的WSL，这里以F盘为例，新的目录为WSL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.导出备份，命名为Ubuntu.tar</span><br><span class="line">wsl --export Ubuntu-&#123;版本&#125; F:\WSL\Ubuntu.tar</span><br><span class="line">2.确定新的目录有备份文件后，注销原有文件</span><br><span class="line">wsl --unregister Ubuntu-&#123;版本&#125;</span><br><span class="line">3.恢复备份文件</span><br><span class="line">wsl --import Ubuntu-&#123;版本&#125; F:\WSL F:\WSL\Ubuntu.tar</span><br></pre></td></tr></table></figure>



<p><img src="/2025/11/21/WSL%E7%9A%84%E5%AE%89%E8%A3%85/image-20251121230524992.png"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/2026/01/13/Java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="1-认识异常"><a href="#1-认识异常" class="headerlink" title="1.认识异常"></a>1.认识异常</h2><p>程序运行过程中可能会出现很多的问题，这些问题可能是代码写的有错误，又或者是输入的数据导致的一些问题……</p>
<p>异常就是对这些问题的表现。Java中的异常体系如下</p>
<p><img src="/2026/01/13/Java%E5%BC%82%E5%B8%B8/java-basic-exception-1.png">  </p>
<p>所有的不正常类都继承于<code>Throwable</code>，分为Error和Exception两类。</p>
<ul>
<li>Error</li>
<li>Exception<ul>
<li>受检异常</li>
<li>非受检异常</li>
</ul>
</li>
</ul>
<p>Error表示JVM发生的错误，例如内存溢出、线程死锁。一旦出现Error，就代表程序崩溃了，一般来说对于开发者来说是没有办法在程序中处理这些Error的。</p>
<p>Exception表示程序运行过程中发生的不期望的事件，通过异常处理机制可以进行恢复。Exception下分为受检异常和非受检异常。</p>
<p>非受检异常：指的是Error和RuntimeException以及它们的子类。在编译时，不会提示和发现这些异常，不要求处理这些异常。例如数组越界异常、除0异常、空指针异常等等。</p>
<p>受检异常：除了非受检异常(Error和RuntimeException以及它们的子类)的异常都为受检异常。Javac强制开发这对受检异常做处理，否则编译不通过。例如IO异常、SQL异常</p>
<p><img src="/2026/01/13/Java%E5%BC%82%E5%B8%B8/image-20260114112614995.png"></p>
<h2 id="2-异常处理机制"><a href="#2-异常处理机制" class="headerlink" title="2. 异常处理机制"></a>2. 异常处理机制</h2><h3 id="2-1-try-catch-finally"><a href="#2-1-try-catch-finally" class="headerlink" title="2.1 try-catch-finally"></a>2.1 try-catch-finally</h3><p>从一个例子中学习异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">           System.out.println(&quot;try 块：开始执行&quot;);</span><br><span class="line">           // 异常</span><br><span class="line">           int result = 10 / 0;</span><br><span class="line">           System.out.println(&quot;这行不会被执行&quot;);</span><br><span class="line">       &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">           System.out.println(&quot;catch 块：捕获到算术异常 - &quot; + e.getMessage());</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;finally 块：无论是否发生异常，这里总会执行&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>try块：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序。在可能发生异常的代码块，应该包含在try块中。</li>
</ul>
<p>　　<strong>【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】</strong></p>
<ul>
<li>catch块：如何处理？比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。</li>
</ul>
<p>　  【<strong>编写catch块的注意事项：多个catch块处理的异常类，要按照先catch子类后catch父类的处理方式，因为会【就近处理】异常（由上自下）。</strong>】</p>
<ul>
<li>finally：最终执行的代码，用于关闭和释放资源。</li>
</ul>
<p><strong>多重捕获</strong></p>
<p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void multipleCatchExample() &#123;</span><br><span class="line">       String str = null;</span><br><span class="line">       int[] array = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           System.out.println(&quot;try 块：尝试访问空字符串&quot;);</span><br><span class="line">           int length = str.length(); // NullPointerException</span><br><span class="line">           System.out.println(&quot;尝试访问数组越界&quot;);</span><br><span class="line">           int value = array[10]; // ArrayIndexOutOfBoundsException</span><br><span class="line">       &#125; catch (NullPointerException e) &#123;</span><br><span class="line">           System.out.println(&quot;catch 块1：捕获到空指针异常 - &quot; + e.getMessage());</span><br><span class="line">       &#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">           System.out.println(&quot;catch 块2：捕获到数组越界异常 - &quot; + e.getMessage());</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           System.out.println(&quot;catch 块3：捕获到其他异常 - &quot; + e.getMessage());</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;finally 块：清理资源&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="finally的注意事项"><a href="#finally的注意事项" class="headerlink" title="finally的注意事项"></a>finally的注意事项</h4><p>在try中，即使有return,break,continue等改变流程的语句，finally最终也会执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int re = bar();</span><br><span class="line">    System.out.println(re);</span><br><span class="line">&#125;</span><br><span class="line">private static int bar() </span><br><span class="line">&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        System.out.println(&quot;finally&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*输出：</span><br><span class="line">finally</span><br><span class="line">5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<p>由于最终会执行finally的代码，所以如果finally也使用了return，会导致finally后renturn的值会覆盖之前return的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int re = bar();</span><br><span class="line">    System.out.println(re);</span><br><span class="line">&#125;</span><br><span class="line">private static int bar() </span><br><span class="line">&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        System.out.println(&quot;finally&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*输出：</span><br><span class="line">finally</span><br><span class="line">1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h4 id="finally中的return会消除前面try-catch块中的异常"><a href="#finally中的return会消除前面try-catch块中的异常" class="headerlink" title="finally中的return会消除前面try-catch块中的异常"></a>finally中的return会消除前面try-catch块中的异常</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            tryMethod();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;捕获到异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            catchMethod();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;捕获到异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int tryMethod() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 5 / 0;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int catchMethod()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 5 / 0;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;catch块中的异常&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="finally中的异常会覆盖前面try-catch块中的异常"><a href="#finally中的异常会覆盖前面try-catch块中的异常" class="headerlink" title="finally中的异常会覆盖前面try-catch块中的异常"></a>finally中的异常会覆盖前面try-catch块中的异常</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            tryMethod();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            catchMethod();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int tryMethod() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 5 / 0;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            throw new RuntimeException(&quot;finally的异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int catchMethod()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 5 / 0;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;catch块中的异常&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            throw new RuntimeException(&quot;finally的异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-throw-throws"><a href="#2-2-throw-throws" class="headerlink" title="2.2 throw &amp; throws"></a>2.2 throw &amp; throws</h3><p>Java中抛出异常有两种方式， <code>throw</code>和<code>throws</code></p>
<h4 id="thow关键字"><a href="#thow关键字" class="headerlink" title="thow关键字"></a>thow关键字</h4><p>使用throw将抛出一个异常对象，如果不进行处理，将由上层调用者进行处理，程序会在这里停止，不会执行后续代码。</p>
<p><img src="/2026/01/13/Java%E5%BC%82%E5%B8%B8/image-20260114113935810.png"></p>
<h4 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h4><p>throws关键字申明将抛出何种类型的异常，作用于方法。当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void readFile(String filename) throws IOException &#123;</span><br><span class="line">       System.out.println(&quot;尝试读取文件: &quot; + filename);</span><br><span class="line">       // FileReader 的构造方法声明了 throws FileNotFoundException</span><br><span class="line">       // 我们不在这里处理，而是继续向上抛出</span><br><span class="line">       FileReader reader = new FileReader(filename);</span><br><span class="line">       System.out.println(&quot;文件读取成功&quot;);</span><br><span class="line">       reader.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="throw与throws的比较"><a href="#throw与throws的比较" class="headerlink" title="throw与throws的比较"></a><strong>throw与throws的比较</strong></h3><p>1、throws出现在方法函数头；而throw出现在函数体。<br>2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>
<h2 id="3-自定义异常"><a href="#3-自定义异常" class="headerlink" title="3.自定义异常"></a>3.自定义异常</h2><p>代码中我们可以自定义异常。需要注意以下三点</p>
<ul>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BusinessException extends Exception&#123;</span><br><span class="line">    /*</span><br><span class="line">    错误码</span><br><span class="line">     */</span><br><span class="line">    String errorCode;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    构造方法</span><br><span class="line">     */</span><br><span class="line">    public BusinessException()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(String message)&#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getErrorCode() &#123;</span><br><span class="line">        return errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setErrorCode(String errorCode) &#123;</span><br><span class="line">        this.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        service();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;系统错误:&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void service() throws BusinessException &#123;</span><br><span class="line">    List&lt;Long&gt; idList = new ArrayList&lt;&gt;();</span><br><span class="line">    idList.add(1L);</span><br><span class="line">    idList.add(2L);</span><br><span class="line">    idList.add(0L);</span><br><span class="line">    for(Long id : idList)&#123;</span><br><span class="line">        if(id == 0)&#123;</span><br><span class="line">            throw new BusinessException(&quot;查询结果错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-使用异常的实践"><a href="#4-使用异常的实践" class="headerlink" title="4.使用异常的实践"></a>4.使用异常的实践</h2><h3 id="4-1-处理异常"><a href="#4-1-处理异常" class="headerlink" title="4.1 处理异常"></a>4.1 处理异常</h3><p>在业务中处理异常主要有两种</p>
<ul>
<li>记录问题，跳过当前问题继续向后执行</li>
<li>抛出异常，返回错误、降级处理等等</li>
</ul>
<p>在处理流程时，应该要注意以下几个点</p>
<ul>
<li>不要通过异常来进行流程控制，因为捕获异常会比正常流程花费更多的时间(创建一个异常对象需要填写堆栈信息)</li>
<li>非受检异常尽量通过预先检查来规避，例如<ul>
<li>空指针提前判空</li>
<li>数组越界提前判断</li>
</ul>
</li>
<li>除非是在最外层的地方如Controller，应该要捕获自己需要的异常，而不是一股脑Exception</li>
<li>catch住的异常，如果不处理，也要记录日志，便于排查问题</li>
</ul>
<h3 id="4-2-阿里巴巴开发手册对于异常处理的建议"><a href="#4-2-阿里巴巴开发手册对于异常处理的建议" class="headerlink" title="4.2 阿里巴巴开发手册对于异常处理的建议"></a>4.2 阿里巴巴开发手册对于异常处理的建议</h3><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p>
<p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。<br>说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。</p>
<p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。</p>
<p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</p>
<p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分</p>
<p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：<br>1）返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。<br>反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。<br>2） 数据库的查询结果可能为null。<br>3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。<br>5） 对于Session中获取的数据，建议NPE检查，避免空指针。<br>6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。</p>
<p>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException &#x2F; ServiceException等。</p>
<p>【参考】对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。</p>
<h2 id="5-深入Excetion本质"><a href="#5-深入Excetion本质" class="headerlink" title="5.深入Excetion本质"></a>5.深入Excetion本质</h2><h3 id="5-1-创建异常的开销？"><a href="#5-1-创建异常的开销？" class="headerlink" title="5.1 创建异常的开销？"></a>5.1 创建异常的开销？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int time;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   time = 10000;</span><br><span class="line">   createObject();</span><br><span class="line">   createException();</span><br><span class="line">   createAndCatchException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void createObject()&#123;</span><br><span class="line">    long start = System.nanoTime();</span><br><span class="line">    for(int i = 0;i &lt; time;i++)&#123;</span><br><span class="line">        new Object();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;创建对象:&quot; + (System.nanoTime() - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void createException()&#123;</span><br><span class="line">    long start = System.nanoTime();</span><br><span class="line">    for(int i = 0;i &lt; time;i++)&#123;</span><br><span class="line">        new Exception();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;创建异常对象:&quot; + (System.nanoTime() - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void createAndCatchException()&#123;</span><br><span class="line">    long start = System.nanoTime();</span><br><span class="line">    for(int i = 0;i &lt; time;i++)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;创建并捕获异常对象:&quot; + (System.nanoTime() - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建对象:252083</span><br><span class="line">创建异常对象:6987208</span><br><span class="line">创建并捕获异常对象:11605084</span><br></pre></td></tr></table></figure>

<p>可以看到建立一个异常对象，是创建普通对象耗时的数十倍，而抛出、接住一个一个异常的时间又是创建一个异常对象的数倍。</p>
<h3 id="5-2-创建异常时发生了什么？"><a href="#5-2-创建异常时发生了什么？" class="headerlink" title="5.2 创建异常时发生了什么？"></a>5.2 创建异常时发生了什么？</h3><p>（1）调用构造方法</p>
<p>调用构造方法，调用父类的构造方法Exception，Throwable的调用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BusinessException(String message)&#123;</span><br><span class="line">    super(message); // 调用Exception的构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public Exception(String message) &#123;</span><br><span class="line">    super(message); // 调用Throwable的构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public Throwable(String message) &#123;</span><br><span class="line">    fillInStackTrace();</span><br><span class="line">    detailMessage = message;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>（2）fillInStackTrace() 本地方法</p>
<p><img src="/image-20260114153247929.png" alt="image-20260114153247929"></p>
<p>在这一步，会保存调用栈信息。<br>调用栈信息包括了</p>
<ul>
<li>类名</li>
<li>方法名</li>
<li>文件名</li>
<li>行号</li>
</ul>
<p>捕获调用栈信息，会遍历线程栈帧，创建 StackTraceElement 数组。这一步耗时很大，也就是为什么创建异常会耗时很大的原因。</p>
<h3 id="5-3-优化"><a href="#5-3-优化" class="headerlink" title="5.3 优化"></a>5.3 优化</h3><p>可以通过禁用堆栈追踪的方式来提高性能，但是一般不建议这么做，因为异常本来就是用于追踪问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyException extends RuntimeException &#123;</span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        // writableStackTrace = false 不捕获堆栈</span><br><span class="line">        super(message, null, false, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》阅读笔记(2)</title>
    <url>/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-判断对象的死亡"><a href="#1-判断对象的死亡" class="headerlink" title="1. 判断对象的死亡"></a>1. 判断对象的死亡</h2><p>通常来说，我们有两种方式来判断对象是否存活</p>
<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
</ul>
<h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p><strong>在对象中添加一个引用计数器，每当有一个地方 引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可 能再被使用的。</strong></p>
<p>引用计数法的判断效率比较高，但是单纯的引用计数法难以解决对象之间互相循环引用的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对象objA和objB都有字段instance</span><br><span class="line">objA.instance=objB</span><br><span class="line">objB.instance=objA</span><br></pre></td></tr></table></figure>

<p>除此之外，这两个对象没有其他引用。如果通过引用计数法，他们的计数都不为0，但实际上这两个对象已经不可能再被访问了</p>
<h3 id="1-2-可达性分析算法-主流的方案"><a href="#1-2-可达性分析算法-主流的方案" class="headerlink" title="1.2 可达性分析算法(主流的方案)"></a>1.2 可达性分析算法(主流的方案)</h3><p>通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251223011734652.png" alt="image-20251223011734652"></p>
<p>在Java中，可以作为GC Roots的对象包括</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态变量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
<li>虚拟机内部的引用</li>
<li>所有同步锁持有的对象</li>
</ul>
<h2 id="2-引用的类型"><a href="#2-引用的类型" class="headerlink" title="2.引用的类型"></a>2.引用的类型</h2><h3 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h3><p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</p>
<h3 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h3><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<h3 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h3><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
<h3 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h3><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。</p>
<h2 id="3-回收方法区"><a href="#3-回收方法区" class="headerlink" title="3.回收方法区"></a>3.回收方法区</h2><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<h3 id="3-1-回收常量"><a href="#3-1-回收常量" class="headerlink" title="3.1 回收常量"></a>3.1 回收常量</h3><p>回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p>
<h3 id="3-2-回收类"><a href="#3-2-回收类" class="headerlink" title="3.2 回收类"></a>3.2 回收类</h3><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要同时满足下面三个条件： </p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 </li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。</p>
<h2 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4.垃圾回收算法"></a>4.垃圾回收算法</h2><h3 id="4-1-分代收集理论"><a href="#4-1-分代收集理论" class="headerlink" title="4.1 分代收集理论"></a>4.1 分代收集理论</h3><p>收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。</p>
<p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安 排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。</p>
<h3 id="4-2-标记-清除算法"><a href="#4-2-标记-清除算法" class="headerlink" title="4.2 标记-清除算法"></a>4.2 标记-清除算法</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。</p>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251223013513236.png" alt="image-20251223013513236"></p>
<p>它的主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对 象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过 程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大 量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="4-3-标记-复制算法"><a href="#4-3-标记-复制算法" class="headerlink" title="4.3 标记-复制算法"></a>4.3 标记-复制算法</h3><p>它将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存 活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复 制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251223013636337.png" alt="image-20251223013636337"></p>
<h3 id="4-4-标记整理算法"><a href="#4-4-标记整理算法" class="headerlink" title="4.4 标记整理算法"></a>4.4 标记整理算法</h3><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存</p>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251223013805576.png" alt="image-20251223013805576"></p>
<h3 id="4-6-GC-Roots扫描查找的问题-复杂"><a href="#4-6-GC-Roots扫描查找的问题-复杂" class="headerlink" title="4.6 GC Roots扫描查找的问题(复杂)"></a>4.6 GC Roots扫描查找的问题(复杂)</h3><p>关于可达性算法中从GC Roots集合中找引用链这个操作较为复杂，这里只是简单的说明一下其中的问题以及HotSpot虚拟机的解决方法。</p>
<p><strong>如何查找到GC Roots集合中相关联的对象？</strong></p>
<p>HotSpot虚拟机使用OopMap的数据结构来得到哪些地方存放着对象引用，能够在特定的位置记录下栈里和寄存器里哪些位置是引用，不需要从方法区中一个个地从GC Roots开始查找</p>
<p><strong>JVM何时记录下这些引用？</strong></p>
<p>实际上HotSpot没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录 了这些信息，这些位置被称为安全点（Safepoint）。有了安全点的设定，也就决定了用户程序执行时 并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才 能够暂停。</p>
<p><strong>没有分配到处理器时间没有执行的线程怎么办？</strong></p>
<p>候线程无法响应虚拟机的中断请求，不能再走 到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于 这种情况，就必须引入安全区域（Safe Region）来解决。</p>
<p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<h3 id="4-7-对象跨代的问题"><a href="#4-7-对象跨代的问题" class="headerlink" title="4.7 对象跨代的问题"></a>4.7 对象跨代的问题</h3><h4 id="4-7-1-卡表"><a href="#4-7-1-卡表" class="headerlink" title="4.7.1 卡表"></a>4.7.1 卡表</h4><p>对象跨代问题(新生代老年代，部分区域回收)可以使用记忆集来解决。</p>
<p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。如果我们不考虑 效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p>
<p>记忆集的实现有不同的精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 </li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 </li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>最常用的是卡精度，实现方式为“卡表”，它定义了记忆集的记录精度、与堆内存的映射关系等。 </p>
<p>卡表可类比于哈希表，每一个Card对应内存中的一块区域，称为卡页，一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代 指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃 圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它 们加入GC Roots中一并扫描。</p>
<h4 id="4-7-2-写屏障"><a href="#4-7-2-写屏障" class="headerlink" title="4.7.2 写屏障"></a>4.7.2 写屏障</h4><p>其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值 后的则叫作写后屏障（Post-Write Barrier）。</p>
<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外 的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p>
<h2 id="5-垃圾回收器"><a href="#5-垃圾回收器" class="headerlink" title="5.垃圾回收器"></a>5.垃圾回收器</h2><h3 id="5-1-Serial收集器"><a href="#5-1-Serial收集器" class="headerlink" title="5.1 Serial收集器"></a>5.1 Serial收集器</h3><p>Serias收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强 调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束(STW)。</p>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251228161952173.png" alt="image-20251228161952173"></p>
<h3 id="5-2-ParNew收集器"><a href="#5-2-ParNew收集器" class="headerlink" title="5.2 ParNew收集器"></a>5.2 ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之 外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX： PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致</p>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251228162029336.png" alt="image-20251228162029336"></p>
<h3 id="5-3-Parallel-Scavenge收集器"><a href="#5-3-Parallel-Scavenge收集器" class="headerlink" title="5.3 Parallel Scavenge收集器"></a>5.3 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</p>
<h3 id="5-4-Serial-Old收集器"><a href="#5-4-Serial-Old收集器" class="headerlink" title="5.4 Serial Old收集器"></a>5.4 Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h3 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5 Parallel Old收集器"></a>5.5 Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现</p>
<h3 id="5-6-CMS收集器-面试常考"><a href="#5-6-CMS收集器-面试常考" class="headerlink" title="5.6 CMS收集器(面试常考)"></a>5.6 CMS收集器(面试常考)</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以<code>获取最短回收停顿时间</code>为目标的收集器，常用于Java应用集中在互联网网站或者基于浏览器的B&#x2F;S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。</p>
<h4 id="5-6-1-CMS收集过程"><a href="#5-6-1-CMS收集过程" class="headerlink" title="5.6.1 CMS收集过程"></a>5.6.1 CMS收集过程</h4><p>CMS收集器是基于标记-清除算法实现的，在老年代进行垃圾回收</p>
<ol>
<li><p>初始标记<br>初始标记是标记一下GC Roots能直接关联到的对象</p>
</li>
<li><p>并发标记<br>并发标记阶段是从GC Roots的直接关联对象开始遍历整个对象图的过程。</p>
</li>
<li><p>重新标记(STW)</p>
<p>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的 标记记录</p>
</li>
<li><p>并发清除<br>并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象</p>
</li>
</ol>
<h4 id="5-6-2-CMS的缺点"><a href="#5-6-2-CMS的缺点" class="headerlink" title="5.6.2 CMS的缺点"></a>5.6.2 CMS的缺点</h4><ul>
<li>对处理器资源非常敏感</li>
<li>无法处理“浮动垃圾”</li>
<li>空间碎片</li>
</ul>
<h3 id="5-7-Garbage-First收集器-面试常考）"><a href="#5-7-Garbage-First收集器-面试常考）" class="headerlink" title="5.7 Garbage First收集器(面试常考）"></a>5.7 Garbage First收集器(面试常考）</h3><p>G1是一款主要面向服务端应用的垃圾收集器。</p>
<p>G1也是遵循分代收集理 论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的 旧对象都能获取很好的收集效果。</p>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作 为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p><strong>G1回收过程</strong></p>
<ul>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。 </li>
<li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。 </li>
<li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 </li>
<li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。</li>
</ul>
<p><img src="/2025/12/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/image-20251228171718742.png" alt="image-20251228171718742"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo和github创建自己的博客</title>
    <url>/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>本篇文章参考<a href="https://hexo.io/zh-cn/docs/"><strong>Hexo官方文档</strong></a>、<a href="https://zhuanlan.zhihu.com/p/265077468"><strong>Hexo博客如何插入图片</strong></a>、 <a href="https://docs.github.com/en/pages/quickstart"><strong>Github Pages</strong></a>，一步一步搭建自己的博客。</p>
<h2 id="1-前置准备"><a href="#1-前置准备" class="headerlink" title="1.前置准备"></a>1.前置准备</h2><p>安装Hexo需要先安装Node.js和Git</p>
<h3 id="1-1-安装Node-js"><a href="#1-1-安装Node-js" class="headerlink" title="1.1 安装Node.js"></a>1.1 安装Node.js</h3><p><a href="https://nodejs.org/zh-cn"><strong>node官网</strong></a>，推荐下载12.0及以上的LTS版本(默认包含npm工具包)，一路安装即可。</p>
<p>输入<code>node -v</code> <code>npm -v</code>验证是否安装成功</p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122143108724.png"></p>
<h3 id="1-2-安装git-已经配置的可跳过，后续命令都在git中完成"><a href="#1-2-安装git-已经配置的可跳过，后续命令都在git中完成" class="headerlink" title="1.2 安装git(已经配置的可跳过，后续命令都在git中完成)"></a>1.2 安装git(已经配置的可跳过，后续命令都在git中完成)</h3><p><a href="https://git-scm.com/"><strong>git官网</strong></a>，一路安装即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version  # 检查是否已经安装git</span><br></pre></td></tr></table></figure>



<p><strong>配置用户名、密码以及密钥</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;github绑定的邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 生成 ssh 密钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;github 注册邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>使用生成ssh密钥的命令后，会生成<code>id_rsa</code> (私有)<code>id_rsa.pub</code>（公有）两个文件，打开<code>id_rsa.pub</code>中的密钥，复制到<code>GitHub-Settings-SSH and GPG Keys</code>页面，创建一个新的SSH key</p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122141133630.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com  # 测试SSH连接</span><br></pre></td></tr></table></figure>

<p>如果成功，会显示Hi，xxx! You’ve successfully authenticated…</p>
<h2 id="2-安装Hexo并初始化"><a href="#2-安装Hexo并初始化" class="headerlink" title="2.安装Hexo并初始化"></a>2.安装Hexo并初始化</h2><p>使用以下命令安装hexo相关工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><strong>初始化项目</strong></p>
<ol>
<li>创建一个新文件夹用来存放博客，并执行hexo init命令</li>
<li>执行npm install安装必备组件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>初始化后，目录结构如图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"> ├── _config.yml # 网站配置信息</span><br><span class="line"> ├── package.json # 应用程序信息</span><br><span class="line"> ├── scaffolds # 模板文件夹</span><br><span class="line"> ├── source # 存放用户资源</span><br><span class="line"> |   ├── _drafts</span><br><span class="line"> |   └── _posts</span><br><span class="line"> └── themes # 主题文件夹</span><br></pre></td></tr></table></figure>



<p><strong>本地部署博客</strong></p>
<ol>
<li>新建博客</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;博客名&quot;</span><br></pre></td></tr></table></figure>

<p>执行此命令会在&#x2F;source&#x2F;_posts目录下创建一个md文件，用markdown编辑器即可对博客进行编辑</p>
<ol start="2">
<li>生成静态网页</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开本地服务器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器打开<code>http://localhost:4000</code>，就可以看到部署的网页</p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122151002542.png"></p>
<h2 id="3-部署到Github-Pages"><a href="#3-部署到Github-Pages" class="headerlink" title="3. 部署到Github Pages"></a>3. 部署到Github Pages</h2><p>如果博客需要其他人也访问，则需要部署到服务器上，在这里选择使用Github Pages，是免费的。访问的地址是<code>https://用户名.github.io</code></p>
<h3 id="3-1-新建一个仓库"><a href="#3-1-新建一个仓库" class="headerlink" title="3.1 新建一个仓库"></a>3.1 新建一个仓库</h3><p><strong>注意点</strong></p>
<ul>
<li><p>仓库一定是<code>public</code>的，否则别人访问不到</p>
</li>
<li><p>仓库名一定是<code>用户名.github.io</code></p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122145400207.png"></p>
</li>
</ul>
<h3 id="3-2-更改hexo配置"><a href="#3-2-更改hexo配置" class="headerlink" title="3.2 更改hexo配置"></a>3.2 更改hexo配置</h3><p>打开目录下_config.Yaml文件</p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122145713620.png"></p>
<p>找到Deployment选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repository: git@github.com:myc1543/myc1543.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>修改type项为git</li>
<li>repository项为仓库地址</li>
<li>branch为main</li>
</ul>
<p>注意每项配置<code>:</code>后有空格</p>
<h3 id="3-3-远程部署"><a href="#3-3-远程部署" class="headerlink" title="3.3 远程部署"></a>3.3 远程部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g ## 生成静态网页</span><br><span class="line">hexo d ## 部署到Github Pages</span><br></pre></td></tr></table></figure>



<p>访问<code>https://用户名.github.io</code> 即可</p>
<h2 id="4-hexo中插入图片"><a href="#4-hexo中插入图片" class="headerlink" title="4.hexo中插入图片"></a>4.hexo中插入图片</h2><p>用md有个蛋疼的问题，就是对图片的展示不是很友好。</p>
<h3 id="4-1-插入图片"><a href="#4-1-插入图片" class="headerlink" title="4.1 插入图片"></a>4.1 插入图片</h3><p>在md中插入图片的语法为<code>![图片描述](图片路径)</code></p>
<p>这里图片路径有三种方式</p>
<ul>
<li>绝对路径</li>
<li>相对路径</li>
<li>网络路径</li>
</ul>
<p>对应的，在hexo中使用图片资源，除了网络路径无需更改，相对路径和绝对路径都是需要先在资源文件下存放， 才能正确显示。</p>
<p><strong>(1)绝对路径引用</strong></p>
<p>绝对路径使用需要在<code>/source</code> 文件夹下创建一个资源文件夹如<code>/source/pictures/</code>,作为全局资源文件夹</p>
<p>引用方式为<code>![](/pictures/picture1.jpg)</code></p>
<p><strong>(2)相对路径引用</strong></p>
<p>hexo提供了一个资源文件管理功能，通过config.yml文件中的<code>post_assert_folder</code>设置为true来打开。此时当创建一个新的md博客，会同步创建一个相同名字的文件夹，在博客中之需要使用相对路径引用图片即可。</p>
<p>举个例子：创建了一个新的博客为blog.md，目录结构为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- source</span><br><span class="line">	- _posts</span><br><span class="line">		- blog.md</span><br><span class="line">		- blog(文件夹)</span><br></pre></td></tr></table></figure>

<p>blog文件夹中存放了1.png，引用方式为<code>![](1.png)</code></p>
<p><strong>预览不正确的问题</strong></p>
<p>但这时，直接使用相对路径引入的图片，只能在<strong>博文详情页</strong>展示，在首页或者存档页的预览会不正确，此时应该改为<code>![](% assert_img 1.png %)</code></p>
<p>这时候可以引入<code>hexo-renderer-marked</code>插件来解决这个问题</p>
<p>使用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-配合Typora来简化操作"><a href="#4-2-配合Typora来简化操作" class="headerlink" title="4.2 配合Typora来简化操作"></a>4.2 配合Typora来简化操作</h3><p>这时候会发现一个问题，就是每次我想使用图片的时候，都需要先在资源文件下存放图片，才能使用，这对复制黏贴的截图来说很不友好。</p>
<p>Typora的设置可以自动将插入的图片复制一份到文章资源文件夹</p>
<p><code>文件-偏好设置-图像</code>，设置为复制到指定路径<code>/.${filename}</code>，并且设置优先显示相对路径</p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122173743632.png"></p>
<p>这时候图片的路径就为<code>文章名/picture.jpg</code>。但是hexo的路径应该是没有前面的前缀的，用全局搜索替换<code>文章名/</code>为空即可。</p>
<p>此时本地typora就显示不出图片，可以设置<code>格式-图像-设置图像根目录</code>来解决</p>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122174149386.png" alt="image-20251122174149386"></p>
<h3 id="4-3-插入图片的总结"><a href="#4-3-插入图片的总结" class="headerlink" title="4.3 插入图片的总结"></a>4.3 插入图片的总结</h3><ol>
<li>下载<code>hexo-renderer-marked</code>插件并修改<code>config.yaml</code>配置</li>
<li>设置Typora插入图片设置(<code>插入到指定路径</code> <code>优先使用相对路径</code>)</li>
</ol>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122174615272.png"></p>
<ol start="3">
<li>使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空</li>
</ol>
<p><img src="/2025/11/22/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/image-20251122174748275.png"></p>
<ol start="4">
<li>设置图片根目录，在本地编辑器显示</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数值计算</title>
    <url>/2026/01/15/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="1-浮点数"><a href="#1-浮点数" class="headerlink" title="1. 浮点数"></a>1. 浮点数</h2><h3 id="1-1浮点数计算"><a href="#1-1浮点数计算" class="headerlink" title="1.1浮点数计算"></a>1.1浮点数计算</h3><p>学过计算机组成原理的同学都知道，在程序中，我们使用二进制并不能准确地表示一个数。以0.1为例，0.1的二进制表示为0.0 0011 0011 0011…，再转化为十进制，就变成了0.1000000000000000055511151231257827021181583404541015625。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(0.1 + 0.2);</span><br><span class="line">// 输出结果：0.30000000000000004</span><br></pre></td></tr></table></figure>

<p>所以我们在使用浮点数时，需要注意可能带来的误差。</p>
<h3 id="1-2-浮点数格式化"><a href="#1-2-浮点数格式化" class="headerlink" title="1.2 浮点数格式化"></a>1.2 浮点数格式化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double num1 = 3.35;</span><br><span class="line">float num2 = 3.35f;</span><br><span class="line">System.out.println(String.format(&quot;%.1f&quot;, num1)); // 输出3.4</span><br><span class="line">System.out.println(String.format(&quot;%.1f&quot;, num2)); // 输出3.3</span><br></pre></td></tr></table></figure>

<p>这就是由精度问题和舍入方式共同导致的，double和float的3.35其实相当于3.350xxx和3.349xxx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.350000000000000088817841970012523233890533447265625</span><br><span class="line">3.349999904632568359375</span><br></pre></td></tr></table></figure>

<p>String.format采用四舍五入的方式进行舍入，取1位小数，double的3.350四舍五入为3.4，而float的3.349四舍五入为3.3。</p>
<h2 id="2-BigDecimal"><a href="#2-BigDecimal" class="headerlink" title="2.BigDecimal"></a>2.BigDecimal</h2><p>涉及到精确计算时，我们常常使用decimal来代替浮点数。但是使用浮点数也有一些注意事项</p>
<h3 id="2-1-使用字符串的构造方法来初始化BigDecimal"><a href="#2-1-使用字符串的构造方法来初始化BigDecimal" class="headerlink" title="2.1 使用字符串的构造方法来初始化BigDecimal"></a>2.1 使用字符串的构造方法来初始化BigDecimal</h3><hr>
<h4 id="使用浮点数来初始化BigDecimal"><a href="#使用浮点数来初始化BigDecimal" class="headerlink" title="使用浮点数来初始化BigDecimal"></a>使用浮点数来初始化BigDecimal</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(new BigDecimal(0.1).add(new BigDecimal(0.2)));</span><br><span class="line">// 输出结果 0.3000000000000000166533453693773481063544750213623046875</span><br></pre></td></tr></table></figure>

<p>对比直接使用浮点数做运算，使用BigDecimal，仅仅是提高了精度，并没有解决根本问题。</p>
<h4 id="使用字符串来初始化BigDecimal"><a href="#使用字符串来初始化BigDecimal" class="headerlink" title="使用字符串来初始化BigDecimal"></a>使用字符串来初始化BigDecimal</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(new BigDecimal(&quot;0.1&quot;).add(new BigDecimal(&quot;0.2&quot;)));</span><br><span class="line">// 输出结果 0.3</span><br></pre></td></tr></table></figure>



<h4 id="double转为字符串，初始化BigDecimal"><a href="#double转为字符串，初始化BigDecimal" class="headerlink" title="double转为字符串，初始化BigDecimal"></a>double转为字符串，初始化BigDecimal</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(new BigDecimal(&quot;3.1&quot;).multiply(new BigDecimal(Double.toString(100))));</span><br><span class="line">// 输出结果 310.00</span><br></pre></td></tr></table></figure>

<p>BigDecimal有scale和precision两个概念</p>
<ul>
<li>scale:小数点右边的位数</li>
<li>precision:有效数字的长度</li>
</ul>
<p><strong>对于BigDecimal乘法操作，返回值的scale是两个数的scale相加</strong></p>
<p>new BigDecimal(“3.1”)得到的为3.1，new BigDecimal(Double.toString(100))得到的为100.0，所以相乘得到310.00</p>
<h3 id="2-2-浮点数的字符串格式化通过BigDecimal来进行"><a href="#2-2-浮点数的字符串格式化通过BigDecimal来进行" class="headerlink" title="2.2 浮点数的字符串格式化通过BigDecimal来进行"></a>2.2 浮点数的字符串格式化通过BigDecimal来进行</h3><p>根据对浮点数的测试，在进行格式化的时候会有精度问题，使用BigDecimal可以避免这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal num1 = new BigDecimal(&quot;3.35&quot;);</span><br><span class="line">BigDecimal num2 = num1.setScale(1, BigDecimal.ROUND_DOWN);</span><br><span class="line">System.out.println(num2); // 3.3</span><br><span class="line">BigDecimal num3 = num1.setScale(1, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">System.out.println(num3); // 3.4</span><br></pre></td></tr></table></figure>



<h3 id="2-3-BigDecimal判等"><a href="#2-3-BigDecimal判等" class="headerlink" title="2.3 BigDecimal判等"></a>2.3 BigDecimal判等</h3><p>BigDecimal的判等会同时判断scale和value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(new BigDecimal(&quot;1&quot;).equals(new BigDecimal(&quot;1.0&quot;))); // false</span><br></pre></td></tr></table></figure>

<p>可以通过compareTo方法只比较数值部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(new BigDecimal(&quot;1&quot;).compareTo(new BigDecimal(&quot;1.0&quot;)) == 0); // true</span><br></pre></td></tr></table></figure>



<h4 id="HashSet-和-HashMap问题"><a href="#HashSet-和-HashMap问题" class="headerlink" title="HashSet 和 HashMap问题"></a>HashSet 和 HashMap问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set hashSet1 = new HashSet&lt;&gt;();</span><br><span class="line">hashSet1.add(new BigDecimal(&quot;1.0&quot;));</span><br><span class="line">System.out.println(hashSet1.contains(new BigDecimal(&quot;1&quot;)));// false</span><br></pre></td></tr></table></figure>

<p>有两个解决方法</p>
<ul>
<li>使用TreeSet替换HashSet，TreeSet不使用hashCode方法，也不使用equals，而是使用compareTo</li>
<li>把BigDecimal存入HashSet或HashMap前，先使用stripTrailingZeros方法去掉尾部的零，比较的时候也去掉尾部的0，确保value相同的BigDecimal，scale也是一致的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set hashSet2 = new HashSet&lt;&gt;();</span><br><span class="line">hashSet2.add(new BigDecimal(&quot;1.0&quot;).stripTrailingZeros());</span><br><span class="line">System.out.println(hashSet2.contains(new BigDecimal(&quot;1.000&quot;).stripTrailingZeros()));// true</span><br></pre></td></tr></table></figure>



<h2 id="3-溢出问题"><a href="#3-溢出问题" class="headerlink" title="3. 溢出问题"></a>3. 溢出问题</h2><p>和小数类似，由于数值是二进制表示，当数值超过了可表示的最大值，就会变成最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + 1);</span><br><span class="line">System.out.println(l + 1 == Long.MIN_VALUE);</span><br><span class="line">--------------------------------------------</span><br><span class="line">输出结果</span><br><span class="line">-9223372036854775808</span><br><span class="line">true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当发生溢出时，没有任何异常，所以难以感知到，要解决这个问题，有以下两种方法</p>
<h3 id="3-1-Exact方法"><a href="#3-1-Exact方法" class="headerlink" title="3.1 Exact方法"></a>3.1 Exact方法</h3><p>使用Math类的addExact、subtractExact等xxExact方法进行数值运算，这些方法可以在数值溢出时主动抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            long l = Long.MAX_VALUE;</span><br><span class="line">            System.out.println(Math.addExact(l, 1));</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.ArithmeticException: long overflow</span><br><span class="line">	at java.lang.Math.addExact(Math.java:809)</span><br></pre></td></tr></table></figure>



<h3 id="3-2-使用大数类BigInteger"><a href="#3-2-使用大数类BigInteger" class="headerlink" title="3.2 使用大数类BigInteger"></a>3.2 使用大数类BigInteger</h3><p>如果希望把计算结果转换一个Long变量的话，可以使用BigInteger的longValueExact方法，在转换出现溢出时，同样会抛出ArithmeticException：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigInteger i = new BigInteger(String.valueOf(Long.MAX_VALUE));</span><br><span class="line">System.out.println(i.add(BigInteger.ONE).toString());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    long l = i.add(BigInteger.ONE).longValueExact();</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9223372036854775808</span><br><span class="line">java.lang.ArithmeticException: BigInteger out of long range</span><br><span class="line">	at java.math.BigInteger.longValueExact(BigInteger.java:4632)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>个性化Hexo配置</title>
    <url>/2025/11/23/%E4%B8%AA%E6%80%A7%E5%8C%96hexo%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-Hexo配置Next主题"><a href="#1-Hexo配置Next主题" class="headerlink" title="1.Hexo配置Next主题"></a>1.Hexo配置Next主题</h2><h3 id="1-1-检查Hexo配置"><a href="#1-1-检查Hexo配置" class="headerlink" title="1.1 检查Hexo配置"></a>1.1 检查Hexo配置</h3><p>输入<code>hexo v</code>命令，出现如下信息，表示Hexo已安装，可以进行后续操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo v</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 8.1.1</span><br><span class="line">hexo-cli: 4.3.2</span><br><span class="line">os: win32 10.0.26200 undefined</span><br><span class="line">node: 24.11.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1-2-安装Next主题"><a href="#1-2-安装Next主题" class="headerlink" title="1.2 安装Next主题"></a>1.2 安装Next主题</h3><ul>
<li>进入站点文件夹，也就是包含<code>themes</code> <code>source</code> <code>_config.yml</code>的文件夹</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>下载next主题</p>
<ul>
<li><strong>创建配置文件</strong></li>
</ul>
<p>站点文件夹下，复制hexo-theme-next下的<code>_config.yml</code>，命名为_config.next.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为什么不直接使用next主题下的配置文件？</strong><ul>
<li>在升级主题时，对这些默认配置文件所做的自定义修改可能会导致冲突或被覆盖，从而造成数据丢失。</li>
</ul>
</li>
</ul>
<h3 id="1-3-配置Next主题"><a href="#1-3-配置Next主题" class="headerlink" title="1.3 配置Next主题"></a>1.3 配置Next主题</h3><p>Hexo配置文件<code>_config.yml</code>找到<code>theme</code>选项，改为<code>next</code>(主题名称)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>



<h3 id="1-4-清理缓存"><a href="#1-4-清理缓存" class="headerlink" title="1.4 清理缓存"></a>1.4 清理缓存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>清理Hexo的缓存，生成本地文件，运行。运行的效果看起来和图片相似，说明安装成功</p>
<p><img src="/2025/11/23/%E4%B8%AA%E6%80%A7%E5%8C%96hexo%E9%85%8D%E7%BD%AE/next-default-scheme.png"></p>
<h2 id="2-个性化设置"><a href="#2-个性化设置" class="headerlink" title="2.个性化设置"></a>2.个性化设置</h2><p>可以对Hexo以及Next作一些设置，满足自己的需求</p>
<h3 id="2-1-Hexo配置"><a href="#2-1-Hexo配置" class="headerlink" title="2.1 Hexo配置"></a>2.1 Hexo配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hexo</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: John Doe</span><br><span class="line">language: en </span><br><span class="line">timezone: &#x27;&#x27; </span><br></pre></td></tr></table></figure>

<ul>
<li>title：网站的名字</li>
<li>subtitle：网站的副标题</li>
<li>description：描述自己的一些关键字</li>
<li>keywords：网站的关键字</li>
<li>author：网站的作者</li>
<li>language：网站的语言</li>
<li>timezone：网站对应的时区，默认使用电脑的时区，如果发布到服务器上，最好手动设置时区，国内的时区一般设置为<code>Asia/Shanghai</code></li>
</ul>
<h3 id="2-2-添加分类与标签"><a href="#2-2-添加分类与标签" class="headerlink" title="2.2 添加分类与标签"></a>2.2 添加分类与标签</h3><p>Hexo支持为文章添加分类<code>categories</code>与标签<code>tags</code></p>
<ul>
<li>首先，配置文章模板，进入<code>/scaffolds</code>文件夹，打开post文件，添加以下配置，可以在创建文章时自动添加模板</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">tags: </span><br></pre></td></tr></table></figure>

<ul>
<li><code>[可选]</code>打开<code>_config.next.yml</code>，找到<code>menu</code>，删除tags和categories的注释，主要应用于菜单栏</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  #home: / || fa fa-home</span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  #archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>创建分类并添加type属性</strong></li>
</ul>
<p>在站点所在文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>成功后提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure>

<p>找到上面<code>index.md</code>文件</p>
<p>默认内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2025-11-23 13:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加<code>type</code>内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories # 可以修改title标题</span><br><span class="line">date: 2025-11-23 13:47:40</span><br><span class="line">type: “categories”</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>添加标签并添加type属性</strong></li>
</ul>
<p>和添加分类类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>成功后提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>

<p>打开index.md，添加type属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2025-11-23 15:38:49</span><br><span class="line">type : &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用分类和标签</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 个性化Hexo配置 </span><br><span class="line">typora-root-url: test</span><br><span class="line">date: 2025-11-23 15:40:54</span><br><span class="line">tags: [工具,hexo]</span><br><span class="line">categories: [技术,工具]</span><br><span class="line">description: 在Hexo中配置Next主题，并且设置一些个性化元素。</span><br></pre></td></tr></table></figure>

<p>分类是一个层级目录，到代表<code>技术</code> -&gt; <code>工具</code>，一级分类为<code>技术</code>，二级分类为<code>工具</code>，[c1,c2,c3]，从左到右，层级为<code>/c1/c2/c3</code></p>
<p>标签是一个同级的目录，没有上下级的区分。 [t1,t2,t3]</p>
<p>在创建分类和标签时，如果不存在，会自动创建；如果已存在，会自动合并</p>
<h3 id="2-3-设置next主题"><a href="#2-3-设置next主题" class="headerlink" title="2.3 设置next主题"></a>2.3 设置next主题</h3><p>next的主题默认为<code>Muse</code>，可以编辑<code>_config.next.yml</code>来更改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>



<h3 id="2-4-设置头像"><a href="#2-4-设置头像" class="headerlink" title="2.4 设置头像"></a>2.4 设置头像</h3><ul>
<li><p>在站点文件夹中，进入<code>/source</code>目录，创建文件夹<code>images</code>，在<code>images</code>中将要保存的头像命名为<code>avatar.jpg</code></p>
</li>
<li><p>修改<code>_config.next.yml</code>的<code>Avatar</code>选项</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  # If true, the avatar will be displayed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-5-搜索功能"><a href="#2-5-搜索功能" class="headerlink" title="2.5 搜索功能"></a>2.5 搜索功能</h3><ul>
<li>安装插件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>_config.yml</code>，增加以下内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编辑<code>_config.next.yml</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-6-增加字数统计以及阅读时间"><a href="#2-6-增加字数统计以及阅读时间" class="headerlink" title="2.6 增加字数统计以及阅读时间"></a>2.6 增加字数统计以及阅读时间</h3><ul>
<li>安装插件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>_config.next.yml</code>配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true # 是否换行显示 字数统计 及 阅读时长</span><br><span class="line">  item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示</span><br><span class="line">  item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示</span><br><span class="line">  awl: 4 # awl（Average Word Length）的数值是设定多少字符统计为一个字（word），中文博客建议设置为 2</span><br><span class="line">  wpm: 275 # （Words Per Minute）是假设的读者阅读速度，多少字（word）统计为阅读时长一分钟。</span><br></pre></td></tr></table></figure>

<p>官方文档的参考值：</p>
<ul>
<li>慢速：200</li>
<li>中速：275</li>
<li>快速：350</li>
</ul>
<h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><p>Hexo以及Next还支持其他的有意思的配置，读者可根据自身需要选择，比如<a href="https://pengtech.net/hexo/blog_seo_optimize.html?t=1763890310451">SEO引擎优化</a>、<a href="https://pengtech.net/hexo/hexo_mermaid_plugin.html?t=1763890368545">图标功能</a>、<a href="https://pengtech.net/hexo/hexo_blog_comments.html?t=1763890399783">评论</a>、<a href="https://theme-next.js.org/">官方文档</a>中也有一些进阶用法。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>判等</title>
    <url>/2026/01/15/%E5%88%A4%E7%AD%89/</url>
    <content><![CDATA[<h2 id="1-判等的工具"><a href="#1-判等的工具" class="headerlink" title="1.判等的工具"></a>1.判等的工具</h2><p>在Java中，有两种方式来判断是否相等：&#x3D;&#x3D;和equals。</p>
<p>&#x3D;&#x3D;是操作符而equals是方法。</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1 &#x3D;&#x3D;"></a>1.1 &#x3D;&#x3D;</h3><p>&#x3D;&#x3D;比较的是直接值。对于基本类型而言，基本类型的值就是直接值。对于引用对象而言，直接值是指针。所以对于包装类型的数值，一般不建议使用&#x3D;&#x3D;。</p>
<h3 id="1-2-equals"><a href="#1-2-equals" class="headerlink" title="1.2 equals"></a>1.2 equals</h3><p>equals是Object类的equals方法，实际上比较的是对象引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj)&#123;</span><br><span class="line">return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在自定义类型中，如果不实现equals方法，默认是比较引用，用&#x3D;&#x3D;判断。</p>
<p><strong>举个例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">    public Point(int x, int y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point p1 = new Point(1,2);</span><br><span class="line">Point p2 = new Point(1,2);</span><br><span class="line">System.out.println(p1.equals(p2));  // 结果为false</span><br></pre></td></tr></table></figure>



<p><strong>重写equals方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">    Point point = (Point) o;</span><br><span class="line">    return x == point.x &amp;&amp; y == point.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于重写的equals方法入参是Object，所以这里需要注意</p>
<ul>
<li>对入参进行判空</li>
<li>对入参的类型进行判断</li>
</ul>
<h3 id="1-3-hashCode"><a href="#1-3-hashCode" class="headerlink" title="1.3 hashCode"></a>1.3 hashCode</h3><p>由于Set是无重复的集合，所以在Set判断是否有某个元素时也会有判等的问题。Set使用hashCode进行判等。在不重写hashCode方法前，默认使用Object超类的实现，使用hashCode来判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;Point&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">Point p1 = new Point(1,2);</span><br><span class="line">Point p2 = new Point(1,2);</span><br><span class="line">set.add(p1);</span><br><span class="line">System.out.println(set.contains(p2)); // 返回false</span><br></pre></td></tr></table></figure>

<p>重写hashCode方法，直接使用Objects.hash方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Objects.hash(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-Lombok"><a href="#2-Lombok" class="headerlink" title="2.Lombok"></a>2.Lombok</h2><p>Lombok的@Data会实现equals和hashCode方法，但是存在继承关系时，@EqualsAndHashCode方法默认实现没有使用父类属性。</p>
<p>可以手动设置callSuper开关为true，来覆盖这种默认行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EqualsAndHashCode(callSuper = true)</span><br></pre></td></tr></table></figure>



<h2 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3.常量池"></a>3.常量池</h2><h3 id="3-1-包装类型常量池"><a href="#3-1-包装类型常量池" class="headerlink" title="3.1 包装类型常量池"></a>3.1 包装类型常量池</h3><p>通过valueOf创建的包装对象，是可以通过缓存来获取对象的。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>0 ~ 127</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>true,false</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>无</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>无</td>
</tr>
</tbody></table>
<p><strong>举个例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer x = 12;</span><br><span class="line">    Integer y = 12;</span><br><span class="line">    Integer a = 143;</span><br><span class="line">    Integer b = 143;</span><br><span class="line">    Integer c = new Integer(1);</span><br><span class="line">    Integer d = new Integer(1);</span><br><span class="line">    System.out.println(x == y); // true</span><br><span class="line">    System.out.println(a == b); // false</span><br><span class="line">    System.out.println(c == d); // false</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Integer x  &#x3D;  12；实际上是Integer x &#x3D; Integer.valueOf(12)，会在缓存池中查找对象，x和y使用的是同一个对象，所以返回true。</li>
<li>a和b超出了-128 - 127的范围</li>
<li>c和d是new出来的对象，不会查找缓存池</li>
</ul>
<h4 id="Integer改变常量池范围"><a href="#Integer改变常量池范围" class="headerlink" title="Integer改变常量池范围"></a>Integer改变常量池范围</h4><p>修改JVM参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:AutoBoxCacheMax=1000</span><br></pre></td></tr></table></figure>



<h3 id="3-2-字符串"><a href="#3-2-字符串" class="headerlink" title="3.2 字符串"></a>3.2 字符串</h3><p>字符串也实现了常量池。一下对象会放到字符串常量池</p>
<ul>
<li>双引号申明的String对象</li>
<li>String提供的intern方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;test&quot;;</span><br><span class="line">        String s2 = &quot;test&quot;;</span><br><span class="line">        String s3 = new String(&quot;test1&quot;);</span><br><span class="line">        String s4 = new String(&quot;test1&quot;);</span><br><span class="line">        String s5 = new String(&quot;test2&quot;).intern();</span><br><span class="line">        String s6 = new String(&quot;test2&quot;).intern();</span><br><span class="line">        System.out.println(s1 == s2); // true</span><br><span class="line">        System.out.println(s3 == s4); // false</span><br><span class="line">        System.out.println(s5 == s6); // true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="字符串常量池的本质"><a href="#字符串常量池的本质" class="headerlink" title="字符串常量池的本质"></a>字符串常量池的本质</h4><p>字符串常量池是一个固定容量的Map，如果容量太小，字符串太多，每一个桶中的字符串数量太多，查找会很慢。</p>
<p>设置JVM参数-XX:StringTableSize，指定更多的桶</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》阅读笔记（1）</title>
    <url>/2025/11/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-第一章“走进“Java”"><a href="#1-第一章“走进“Java”" class="headerlink" title="1.第一章“走进“Java”"></a>1.第一章“走进“Java”</h2><p><strong>Java的优势之JVM</strong></p>
<ul>
<li>虚拟机层面屏蔽技术的复杂性和操作系统的差异性</li>
</ul>
<h2 id="2-第二章“Java内存区域与内存溢出异常”"><a href="#2-第二章“Java内存区域与内存溢出异常”" class="headerlink" title="2.第二章“Java内存区域与内存溢出异常”"></a>2.第二章“Java内存区域与内存溢出异常”</h2><h3 id="2-1-运行时数据区域"><a href="#2-1-运行时数据区域" class="headerlink" title="2.1 运行时数据区域"></a>2.1 运行时数据区域</h3><p><img src="/2025/11/24/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20251124231738862.png" alt="JVM内存区域"></p>
<h4 id="2-1-1程序计数器"><a href="#2-1-1程序计数器" class="headerlink" title="2.1.1程序计数器"></a>2.1.1程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器(唯一不会出现OOM的区域)</p>
<p>因为Java是多线程执行的，每个处理器在一个时间内只会执行一条线程内的指令，所以每条线程都要有单独的程序计数器，为了线程切换后能恢复到正确的执行位置。</p>
<h4 id="2-1-2-Java虚拟机栈"><a href="#2-1-2-Java虚拟机栈" class="headerlink" title="2.1.2 Java虚拟机栈"></a>2.1.2 Java虚拟机栈</h4><p>虚拟机栈是线程私有的，生命周期和线程相同。描述的是Java方法执行的线程内存模型。每个方法被执行的时候，会同步创建栈帧。</p>
<ul>
<li><p>栈帧</p>
<ul>
<li><p>局部变量表：编译器可知的基本数据类型、对象引用、返回地址</p>
</li>
<li><p>操作数栈：用于暂存计算的操作数和结果</p>
</li>
<li><p>动态链接：符号引用(字符串)转化内直接引用(指针)</p>
</li>
<li><p>方法出口</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-3-本地方法栈"><a href="#2-1-3-本地方法栈" class="headerlink" title="2.1.3 本地方法栈"></a>2.1.3 本地方法栈</h4><p>本地方法栈执为虚拟机使用到的本地方法服务</p>
<h4 id="2-1-4-Java堆"><a href="#2-1-4-Java堆" class="headerlink" title="2.1.4 Java堆"></a>2.1.4 Java堆</h4><p>堆是虚拟机锁管理的内存中最大的一块，被所有线程共享。在虚拟机启动时创建，存放对象实例(所有还是大部分？)</p>
<p>从内存分配的角度来看，堆中还可以划分出线程私有的分配缓冲区。</p>
<p><strong>改变Java堆的大小</strong></p>
<ul>
<li>-Xmx</li>
<li>-Xms</li>
</ul>
<p><strong>字符串常量池</strong></p>
<p>编译器可确定的字符串常量自动入池，运行时生成的字符串需要通过intern()手动入池</p>
<h4 id="2-1-5-方法区"><a href="#2-1-5-方法区" class="headerlink" title="2.1.5 方法区"></a>2.1.5 方法区</h4><p>方法区是各个线程共享的内存区域，存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<h4 id="2-1-6-运行时常量池"><a href="#2-1-6-运行时常量池" class="headerlink" title="2.1.6 运行时常量池"></a>2.1.6 运行时常量池</h4><p>运行时常量池是方法区的一部分，存放编译器生成的各种字面量与符号引用</p>
<p>String.intern</p>
<h4 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7  直接内存"></a>2.2.7  直接内存</h4><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p>
<h3 id="2-3HotSpot虚拟机对象探秘"><a href="#2-3HotSpot虚拟机对象探秘" class="headerlink" title="2.3HotSpot虚拟机对象探秘"></a>2.3HotSpot虚拟机对象探秘</h3><h4 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1 对象的创建"></a>2.3.1 对象的创建</h4><p>当虚拟机遇到new字节码指令时，首先回去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析、初始化过，如果没有，先执行类的加载。</p>
<ul>
<li>为新生对象分配内存，根据Java堆的内存是否规整，选择指针碰撞或空闲列表的方式分配内存<ul>
<li>针对并发问题，有CAS和本地线程分配缓冲</li>
</ul>
</li>
<li>内存分配完成后，必须将分配到的内存空间初始化为零值</li>
<li>对对象进行必要的设置</li>
<li>执行构造函数，对对象进行初始化</li>
</ul>
<h4 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h4><p>对象在HotSpot虚拟机中的存储布局可以分为三个部分：对象头、实例数据、对齐填充。</p>
<p>*** 对象头***</p>
<ul>
<li>对象自身的运行时数据(Mark Word)<ul>
<li>哈希码</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
</ul>
</li>
<li>类型指针<ul>
<li>对象指向它的类型元数据的指针</li>
</ul>
</li>
</ul>
<p><em><strong>实例数据</strong></em></p>
<ul>
<li>程序代码中所定义的各种类型的字段内容</li>
</ul>
<p>*** 对齐填充***</p>
<ul>
<li>占位符，符合对象的起始地址是8字节的整数倍</li>
</ul>
<h4 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h4><p>Java程序通过栈上的reference数据来操作堆上的具体对象。reference是一个指向对象的引用，通过引用去访问对象的方式主要有句柄和直接指针两种</p>
<p>*** 句柄***‘</p>
<ul>
<li>堆中内存划分出一块作为句柄池，reference中存储的是对象的句柄地址，句柄在包含对象实例数据和对象类型数据各自具体的地址信息。</li>
</ul>
<p><em><strong>直接指针</strong></em></p>
<p>存储的是对象地址</p>
<h3 id="2-4-OOM"><a href="#2-4-OOM" class="headerlink" title="2.4 OOM"></a>2.4 OOM</h3><h4 id="2-4-1-堆溢出"><a href="#2-4-1-堆溢出" class="headerlink" title="2.4.1 堆溢出"></a>2.4.1 堆溢出</h4><p>对象太多，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p>
<h4 id="2-4-2-栈溢出"><a href="#2-4-2-栈溢出" class="headerlink" title="2.4.2  栈溢出"></a>2.4.2  栈溢出</h4><p>栈溢出的本质是新的栈帧内存无法分配的时候，导致OOM。</p>
<p>有两种情况</p>
<ul>
<li>栈帧太大</li>
<li>虚拟机栈容量太小</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>日期与时间</title>
    <url>/2026/01/15/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="1-从现实角度看日期和时间"><a href="#1-从现实角度看日期和时间" class="headerlink" title="1. 从现实角度看日期和时间"></a>1. 从现实角度看日期和时间</h2><p>在日常生活中，我们说早上八点，默认是对应了北京时间，也就是北京时间的早上八点。但是在其他地区，在北京时间早上八点的此时此刻，对应的就是纽约时间的前一天晚上9点。所以在使用日期的时候，一定要注意地区差异。</p>
<p><strong>补充知识</strong></p>
<p>时区的概念源于地理上的时区。地球自转一圈为24小时，转过360度。所以每个地方的本地时间都不相同，经度每相差15度，本地时间相差1小时。</p>
<p>由于每个地方的本地时间都不同，所以引出了更大范围的时区的概念。</p>
<p><img src="/2026/01/15/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/1153954-20230117192119560-1554666043.png" alt="世界时区划分"> </p>
<p>以本初子午线为0经度，每15度为一个时区。更通用于地区统一时间。比如我国的经度横跨 73°-135°，地理上包括5个时区，但是为了统一，就使用东八区的时间作为全国统一的北京时间。</p>
<p>现在我们知道了每个地区的时间是不同的，那有没有统一的时间来表示当前时间？</p>
<p>有的，<strong>时间戳就是一个全球统一的时间，不会因为地区差异而改变。时间戳（Unix Timestamp）是一个绝对时间点，表示从 1970-01-01 00:00:00 UTC 以来经过的秒数（或毫秒数）</strong></p>
<h2 id="2-Java中的时间表示"><a href="#2-Java中的时间表示" class="headerlink" title="2.Java中的时间表示"></a>2.Java中的时间表示</h2><h3 id="2-1-System"><a href="#2-1-System" class="headerlink" title="2.1 System"></a>2.1 System</h3><p>系统为我们提供了获取当前毫秒时间戳的方式，注意要使用long类型来存储，避免溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.currentTimeMillis()</span><br><span class="line">// 1768464868132</span><br></pre></td></tr></table></figure>



<h3 id="2-2-Date"><a href="#2-2-Date" class="headerlink" title="2.2 Date"></a>2.2 Date</h3><p>Date本质是一个毫秒时间戳，没有时区的概念，存储从 1970-01-01 00:00:00 UTC 的毫秒数</p>
<h4 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Date() &#123;</span><br><span class="line">        this(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>本质是保存当前的毫秒时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Date().getTime()</span><br></pre></td></tr></table></figure>

<p>获取Date的时间戳</p>
<h4 id="有参构造方法"><a href="#有参构造方法" class="headerlink" title="有参构造方法"></a>有参构造方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Date(int year, int month, int date, int hrs, int min, int sec) &#123;</span><br><span class="line">        int y = year + 1900;</span><br><span class="line">        // month is 0-based. So we have to normalize month to support Long.MAX_VALUE.</span><br><span class="line">        if (month &gt;= 12) &#123;</span><br><span class="line">            y += month / 12;</span><br><span class="line">            month %= 12;</span><br><span class="line">        &#125; else if (month &lt; 0) &#123;</span><br><span class="line">            y += CalendarUtils.floorDivide(month, 12);</span><br><span class="line">            month = CalendarUtils.mod(month, 12);</span><br><span class="line">        &#125;</span><br><span class="line">        BaseCalendar cal = getCalendarSystem(y);</span><br><span class="line">        cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.getDefaultRef());</span><br><span class="line">        cdate.setNormalizedDate(y, month + 1, date).setTimeOfDay(hrs, min, sec, 0);</span><br><span class="line">        getTimeImpl();</span><br><span class="line">        cdate = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Date这里的年是计算和1900的差值，月是从0-11而不是1-12。</p>
<p><strong>不建议使用Date来指定时间</strong></p>
<h3 id="2-3-Calendar"><a href="#2-3-Calendar" class="headerlink" title="2.3 Calendar"></a>2.3 Calendar</h3><p>Calendar 是 Java 提供的日期时间类，用来替代 Date 的很多已废弃方法。 它是一个抽象类，通常使用其子类 。Calendar是有时区的</p>
<h4 id="获取Calendar实例"><a href="#获取Calendar实例" class="headerlink" title="获取Calendar实例"></a>获取Calendar实例</h4><p>默认使用当前系统的时区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">// 指定时区</span><br><span class="line">Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));</span><br><span class="line">// 修改时区</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calendar.getTime(); // 当前时间 Date类型</span><br><span class="line">calendar.getTimeInMillis(); // 当前时间戳</span><br></pre></td></tr></table></figure>

<h4 id="指定时间"><a href="#指定时间" class="headerlink" title="指定时间"></a>指定时间</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过Date来设置时间</span><br><span class="line">public final void setTime(Date date) &#123;</span><br><span class="line">       setTimeInMillis(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 毫秒时间戳来设置</span><br><span class="line">calendar.setTimeInMillis(timestamp);  </span><br><span class="line"></span><br><span class="line">//  指定时间</span><br><span class="line">public final void set(int year, int month, int date, int hourOfDay, int minute,</span><br><span class="line">                         int second)</span><br><span class="line">   &#123;</span><br><span class="line">       set(YEAR, year);</span><br><span class="line">       set(MONTH, month);</span><br><span class="line">       set(DATE, date);</span><br><span class="line">       set(HOUR_OF_DAY, hourOfDay);</span><br><span class="line">       set(MINUTE, minute);</span><br><span class="line">       set(SECOND, second);</span><br><span class="line">   &#125;</span><br><span class="line">calendar.set(2019, Calendar.DECEMBER, 29,0,0,0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意通过指定时间来初始化，年是正常的年，月是0-12，所以推荐通过枚举类初始化月份</p>
<h4 id="操作日期-add"><a href="#操作日期-add" class="headerlink" title="操作日期 - add"></a>操作日期 - add</h4><p>add方法会自动进位&#x2F;退位,比如1月31日+1个月 &#x3D; 2月28日</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calendar.add(Calendar.YEAR, 1);          // 加1年</span><br><span class="line">calendar.add(Calendar.MONTH, -3);        // 减3个月</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, 7);  // 加7天</span><br><span class="line">calendar.add(Calendar.HOUR_OF_DAY, 5);   // 加5小时</span><br></pre></td></tr></table></figure>



<h4 id="操作日期-roll"><a href="#操作日期-roll" class="headerlink" title="操作日期 - roll"></a>操作日期 - roll</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calendar.roll(Calendar.DAY_OF_MONTH, 1);  // 日期+1,不影响月份</span><br></pre></td></tr></table></figure>

<p>不会进位,只在当前单位范围内循环</p>
<h2 id="3-日期字符串"><a href="#3-日期字符串" class="headerlink" title="3.日期字符串"></a>3.日期字符串</h2><p>通常，在业务中往往使用时间戳来传递，但是在前端展示时，通常是<code>2026-01-13 11:01</code>这种形式。所以这里有一个转换，字符串转为时间类型和时间类型转换为字符串</p>
<p>可以参考一下格式</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>yyyyMMdd</td>
<td>20250115</td>
</tr>
<tr>
<td><code>yyyy-MM-dd</code></td>
<td><code>2025-01-15</code></td>
</tr>
<tr>
<td><code>yyyy-MM-dd HH</code></td>
<td><code>2025-01-15 08</code></td>
</tr>
<tr>
<td><code>yyyy-MM-dd HH:mm</code></td>
<td><code>2025-01-15 08:30</code></td>
</tr>
<tr>
<td><code>yyyy-MM-dd HH:mm:ss</code></td>
<td><code>2025-01-15 08:30:45</code></td>
</tr>
<tr>
<td><code>yyyyMMdd HH:mm</code></td>
<td><code>20250115 08:30</code></td>
</tr>
<tr>
<td><code>yyyy-MM-ddHH:mm:ss</code></td>
<td><code>2025-01-15T08:30:45</code></td>
</tr>
<tr>
<td><code>HH:mm</code></td>
<td><code>08:30</code></td>
</tr>
<tr>
<td><code>MM月dd日</code></td>
<td><code>01月15日</code></td>
</tr>
</tbody></table>
<h3 id="3-1-字符串转时间"><a href="#3-1-字符串转时间" class="headerlink" title="3.1 字符串转时间"></a>3.1 字符串转时间</h3><p>DateFormat将时间字符串转为时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static Date getDateForString(String dateStr, String pattern)&#123;</span><br><span class="line">        Date date=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            DateFormat fmt =new SimpleDateFormat(pattern);</span><br><span class="line">            date = fmt.parse(dateStr);</span><br><span class="line">            return date;</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-时间转字符串"><a href="#3-2-时间转字符串" class="headerlink" title="3.2 时间转字符串"></a>3.2 时间转字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String getStringForDate(Date date, String pattern) &#123;</span><br><span class="line">       if (date == null) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           SimpleDateFormat sdf = new SimpleDateFormat(pattern);</span><br><span class="line">           return sdf.format(date);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>事务(1)</title>
    <url>/2026/01/16/%E4%BA%8B%E5%8A%A1-1/</url>
    <content><![CDATA[<p>最近在看事务相关的问题，所以打算把事务写成一个专题，从存储层的事务到应用层的事务。</p>
<h2 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h2><p>事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。简单来说就是，多条sql是一个整体，要么全都执行成功，要么全部执行失败。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>某人要在商店使购买100元的东西，当中至少包括两个操作：</p>
<ol>
<li>该人账户减少100元</li>
<li>商店账户增加100元</li>
</ol>
<p>事务就是要确保以上两个操作（整个“事务”）都能完成，或一起取消；否则就会出现100元平白消失或出现的情况</p>
<h2 id="2-事务的特性-ACID"><a href="#2-事务的特性-ACID" class="headerlink" title="2.事务的特性-ACID"></a>2.事务的特性-ACID</h2><p>事务应该拥有以下四个特性</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。<em>一致状态</em>的含义是数据库中的数据应满足完整性约束。</li>
<li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<p>只有保证了AID，才能保证一致性。</p>
<p><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/AID-%3EC.png" alt="AID-&gt;C"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-验证ACID"><a href="#3-验证ACID" class="headerlink" title="3.验证ACID"></a>3.验证ACID</h2><p>现在我们有一张账户表，里面记录着余额。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    balance INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>有A和B两个人，账户都为100</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO account(name, balance) VALUES (&#x27;A&#x27;, 100), (&#x27;B&#x27;, 100);</span><br></pre></td></tr></table></figure>



<h3 id="3-1-原子性"><a href="#3-1-原子性" class="headerlink" title="3.1 原子性"></a>3.1 原子性</h3><h4 id="执行成功"><a href="#执行成功" class="headerlink" title="执行成功"></a>执行成功</h4><p><strong>转账前</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |     100 |</span><br><span class="line">|  2 | B    |     100 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>



<p>A向B转账10元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">start transaction;</span><br><span class="line">UPDATE account SET balance = balance - 10 WHERE name = &#x27;A&#x27;;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE name = &#x27;B&#x27;;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>转账成功后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |      90 |</span><br><span class="line">|  2 | B    |     110 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>



<h4 id="执行失败"><a href="#执行失败" class="headerlink" title="执行失败"></a>执行失败</h4><p><strong>转账前</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |      90 |</span><br><span class="line">|  2 | B    |     110 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>



<p>A向B转账10元，失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">start transaction;</span><br><span class="line">UPDATE account SET balance = balance - 10 WHERE name = &#x27;A&#x27;;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE name = &#x27;B&#x27;;</span><br><span class="line">-- 更新不存在的数据，发生错误</span><br><span class="line">UPDATE account SET unknown = 1; </span><br><span class="line">-- 回滚事务</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<p><strong>转账后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from account;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |      90 |</span><br><span class="line">|  2 | B    |     110 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>



<h3 id="3-2-持久性"><a href="#3-2-持久性" class="headerlink" title="3.2 持久性"></a>3.2 持久性</h3><p>事务提交后，修改永久保存到数据库，即使系统崩溃也不丢失。</p>
<p>A的账户到账100元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">start transaction;</span><br><span class="line">UPDATE account SET balance = balance + 100 WHERE name = &#x27;A&#x27;;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p><strong>到账前</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |      90 |</span><br><span class="line">|  2 | B    |     110 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>

<p><strong>到账后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |     190 |</span><br><span class="line">|  2 | B    |     110 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>

<p><strong>模拟故障</strong></p>
<p>在事务提交后立即关闭数据库，重启后验证数据是否保留</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | A    |     190 |</span><br><span class="line">|  2 | B    |     110 |</span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>



<h3 id="3-3-隔离性"><a href="#3-3-隔离性" class="headerlink" title="3.3 隔离性"></a>3.3 隔离性</h3><p>MySQL 提供四种事务隔离级别：读未提交、读已提交、可重复读（默认）、串行化。不同的食事务隔离级别，是在数据一致性和速度之间的权衡。</p>
<h4 id="1-读未提交-Read-Uncommitted"><a href="#1-读未提交-Read-Uncommitted" class="headerlink" title="(1)读未提交 Read Uncommitted"></a>(1)读未提交 Read Uncommitted</h4><p>允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p><strong>脏读</strong></p>
<p>能够读取到未提交的事务的执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">START TRANSACTION; -- 开启事务</span><br><span class="line">UPDATE account SET balance = balance + 100 WHERE name = &#x27;A&#x27;;</span><br><span class="line">-- 不执行COMMIT，事务未提交</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话2</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT balance FROM account WHERE name = &#x27;A&#x27;; </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>会话1(初始数据)</th>
<th>会话1(会话2开启事务后)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117213843383.png"></td>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117213855509.png" alt="image-20260117213855509"></td>
</tr>
</tbody></table>
<p>可以看到，会话2中查询的结果是会话1中sql执行的结果。会话1的事务还没有提交，其他事务就可以读取到结果，造成了脏读。</p>
<h4 id="2-读已提交-READ-COMMITTED"><a href="#2-读已提交-READ-COMMITTED" class="headerlink" title="(2)读已提交 READ-COMMITTED"></a>(2)读已提交 READ-COMMITTED</h4><p>读已提交隔离级别，解决了脏读的问题，但没有解决可重复读(同一个事务内前后读取的结果不同)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT balance FROM account WHERE name = &#x27;A&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话2</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance = 2000 WHERE name = &#x27;A&#x27;;</span><br><span class="line">COMMIT; -- 提交事务</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SELECT balance FROM account WHERE name = &#x27;A&#x27;;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>初始数据</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117214247313.png" alt="image-20260117214247313"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>会话2提交事务前</th>
<th>会话2提交事务后</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117214729349.png" alt="image-20260117214729349"></td>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117214823134.png" alt="image-20260117214823134"></td>
</tr>
</tbody></table>
<p>可以看到，读未提交解决了脏读的问题，没有被会话2未提交的事务影响。<br>但是可以发现，在会话1的同一个事务中，读取同一条数据的结果不同，这就是不可重复读。</p>
<h4 id="3-可重复读-REPEATABLE-READ"><a href="#3-可重复读-REPEATABLE-READ" class="headerlink" title="(3)可重复读 REPEATABLE-READ"></a>(3)可重复读 REPEATABLE-READ</h4><p>可重复读，针对的是读已提交的不可重复读。在同一个事务内读取的结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT balance FROM account WHERE name = &#x27;A&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话2</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE account SET balance = 2000 WHERE name = &#x27;A&#x27;;</span><br><span class="line">COMMIT; -- 提交事务</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SELECT balance FROM account WHERE name = &#x27;A&#x27;;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>初始数据</th>
<th>会话2提交事务后</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117215635667.png" alt="image-20260117215635667"></td>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117215755132.png" alt="image-20260117215755132"></td>
</tr>
</tbody></table>
<p>可重复读，同一个事务内读取到的结果一致。</p>
<p>可重复读没有解决幻读的问题(读取到并不存在的数据)。在MySQL中，通过MVCC和锁，能够解决大部分幻读的问题。</p>
<h4 id="可重复读-幻读"><a href="#可重复读-幻读" class="headerlink" title="可重复读 - 幻读"></a>可重复读 - 幻读</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT * FROM account; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话2</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO account values(null,&#x27;D&#x27;,200);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SELECT * FROM account; </span><br><span class="line">UPDATE account SET balance = 2000 WHERE name = &#x27;D&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>会话2事务提交前</th>
<th>会话2事务提交后</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117221109954.png" alt="image-20260117221109954"></td>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117222630040.png" alt="image-20260117222630040"></td>
</tr>
</tbody></table>
<p>可以发现，在会话1中，竟然更新了不存在的数据。提交事务后，确实name &#x3D; ‘D’的数据确实被修改了</p>
<h4 id="4-可串行化-SERIALIZABLE"><a href="#4-可串行化-SERIALIZABLE" class="headerlink" title="(4)可串行化 SERIALIZABLE"></a>(4)可串行化 SERIALIZABLE</h4><p>所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 会话2</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">INSERT INTO account values(null,&#x27;F&#x27;,400);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>会话1事务提交前</th>
<th>会话1事务提交后</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117223050140.png" alt="image-20260117223050140"></td>
<td><img src="/2026/01/16/%E4%BA%8B%E5%8A%A1-1/image-20260117223107072.png" alt="image-20260117223107072"></td>
</tr>
</tbody></table>
<p>在会话1提交事务前，会话2无法插入数据。直到事务提交后，才能插入。</p>
<h3 id="3-4-一致性"><a href="#3-4-一致性" class="headerlink" title="3.4 一致性"></a>3.4 一致性</h3><p>一致性是由上面三种特性共同实现，所以在这里就不进行演示。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>事务(2)</title>
    <url>/2026/01/23/%E4%BA%8B%E5%8A%A1-2/</url>
    <content><![CDATA[<p>在上篇文章，我们讲到了MySQL事务的四个特性ACID。这次，从ACID的特性的实现原理来解析MySQL事务的实现原理。</p>
<h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h2><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。<br>当事务执行失败的时候，需要对已经执行的操作做回滚，在MySQL的InnoDB引擎中，使用undo log日志进行回滚</p>
<h3 id="1-1-undo-log"><a href="#1-1-undo-log" class="headerlink" title="1.1 undo log"></a>1.1 undo log</h3><p>undo log是记录了相反的操作，比如insert一条记录，undo log就记录了一条delete，update一条记录，就记录一条相反的update记录。</p>
<p>undo log分为两种</p>
<ul>
<li>Insert类型：insert语句</li>
<li>Update类型：update语句，delete语句</li>
</ul>
<p>删除记录时，实际上并不是真的删除，而是修改一下Delete Mark标记，所以delete操作也是updat操作。</p>
<h3 id="1-2-TODO"><a href="#1-2-TODO" class="headerlink" title="1.2 TODO"></a>1.2 TODO</h3><ul>
<li>undo log 持久化</li>
<li>undo log 物理存储组织</li>
<li>undo log清理</li>
</ul>
<h2 id="2-持久性"><a href="#2-持久性" class="headerlink" title="2. 持久性"></a>2. 持久性</h2><p>事务一旦提交，对数据库的改变是永久的。数据持久化到磁盘中。</p>
<h3 id="2-1-数据丢失？"><a href="#2-1-数据丢失？" class="headerlink" title="2.1 数据丢失？"></a>2.1 数据丢失？</h3><p>因为数据最终要存储在硬盘当中，如果每次提交事务都直接保存到硬盘中，MySQL的速度会十分慢。所以在提交事务时，先保存到内存中， 再从内存中保存到硬盘中。从内存保存到硬盘中，可能会出现系统故障，比如断电，这时候就需要持久性。</p>
<h3 id="2-2-Buffer-Pool"><a href="#2-2-Buffer-Pool" class="headerlink" title="2.2 Buffer Pool"></a>2.2 Buffer Pool</h3><p>InnoDB借助内存来提升操作效率。Buffer Pool是InnoDB实现的一个缓存模式。</p>
<ul>
<li>读取数据时，MySQL会先访问Buffer Pool，有则返回，没有读取硬盘</li>
<li>修改数据，如果Buffer Pool中存在数据，直接修改Buffer Pool所在的数据页，标记为脏页，通过后台线程写回脏页。</li>
</ul>
<p>InnoDB按16KB一页进行划分</p>
<h3 id="2-3-redo-log"><a href="#2-3-redo-log" class="headerlink" title="2.3 redo log"></a>2.3 redo log</h3><p>上一条讲到，MySQL读取和修改数据都有通过内存，但是内存是做不到持久化的，需要同步到硬盘中。InnoDB 通过redo log来解决这个问题。</p>
<p>redo log是物理日志，记录了在哪一页的哪一个偏移量的修改。每当数据更新时，会把redo log记录到redo log buffer中，然后刷盘到redo log文件中。</p>
<p><strong>redo log也是将数据写入磁盘，为什么不直接将脏页写到磁盘中？</strong></p>
<ul>
<li>将脏页写回磁盘是随机IO，redo log是追加操作，是顺序IO</li>
<li>脏页是以一个数据页为单位，需要将整页写入，redo log只包含真正要写入的</li>
</ul>
<p><img src="/../%E4%BA%8B%E5%8A%A1-2/03.png" alt="img"></p>
<h4 id="2-3-1-刷盘时机"><a href="#2-3-1-刷盘时机" class="headerlink" title="2.3.1 刷盘时机"></a>2.3.1 刷盘时机</h4><ul>
<li>0:事务提交时不刷盘，每秒刷盘一次</li>
<li>1:事务提交时立即刷盘</li>
<li>2:事务提交时写入操作系统缓存</li>
</ul>
<h4 id="2-3-2-日志文件组"><a href="#2-3-2-日志文件组" class="headerlink" title="2.3.2 日志文件组"></a>2.3.2 日志文件组</h4><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 redo log 日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写</p>
<p><img src="/../%E4%BA%8B%E5%8A%A1-2/10.png" alt="img"></p>
<p>日志文件组中有write pos，checkpoint</p>
<ul>
<li>write pos记录当前位置，一边写一边往后移</li>
<li>checkoutpoint是当前擦除的位置</li>
</ul>
<p>每次刷盘redolog记录到日志文件组中，write pos位置后移。</p>
<p>次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 redo log 记录，并把 <code>checkpoint</code> 后移更新。<code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 redo log 记录。</p>
<h2 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3.隔离性"></a>3.隔离性</h2><p>隔离性是事务和事务之间是隔离的。在InnoDB中，事务依靠锁和MVCC机制来实现。</p>
<ul>
<li>一个事务写操作对另一个事务写操作的影响：锁机制</li>
<li>一个事务写操作对另一个事务读操作：MVCC</li>
</ul>
<h3 id="3-1-锁"><a href="#3-1-锁" class="headerlink" title="3.1 锁"></a>3.1 锁</h3><p>同一时刻只能有一个事务对数据进行写操作。<br>锁机制可以概括为：<br><strong>事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</strong></p>
<p>按照粒度，锁可以分为行锁和表锁以及其他锁。表锁在操作时会锁定整张表，行锁只锁定一条记录。所以行锁比表锁的性能更好。</p>
<h3 id="3-2-MVCC"><a href="#3-2-MVCC" class="headerlink" title="3.2 MVCC"></a>3.2 MVCC</h3><p>MVCC是针对读数据的方案，读不加锁。MVCC基于以下结构</p>
<ul>
<li>隐藏列，每条记录都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等</li>
<li>基于undo log的版本链，每条记录包含了执行undo log的指针，每条undo log也会指向更早版本的undo log，从而形成一条版本链</li>
<li>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。</li>
</ul>
<p><strong>判断可见性</strong></p>
<ul>
<li>low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id。如果数据的事务id大于等于low_limit_id，则对该ReadView不可见。</li>
<li>up_limit_id：表示生成ReadView时当前系统中活跃的读写事务中最小的事务id。如果数据的事务id小于up_limit_id，则对该ReadView可见。</li>
<li>rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。如果数据的事务id在low_limit_id和up_limit_id之间，则需要判断事务id是否在rw_trx_ids中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见；如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。</li>
</ul>
<p>在RC隔离级别下</p>
<ul>
<li><strong>每条 SELECT 语句都创建新的 Read View</strong></li>
<li>保证读到<strong>最新已提交</strong>的数据</li>
</ul>
<p>在RR隔离级别下</p>
<ul>
<li><strong>Read View 在事务开始时创建，直到事务结束</strong></li>
<li>保证事务内多次读取看到<strong>相同的数据快照</strong></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring接入AI模型</title>
    <url>/2026/01/29/Spring%E6%8E%A5%E5%85%A5AI%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="1-SpringAI介绍"><a href="#1-SpringAI介绍" class="headerlink" title="1.SpringAI介绍"></a>1.SpringAI介绍</h2><p><code>SpringAI</code>解决了AI集成的根本难题：将企业数据和AI模型连接起来。<br>Spring AI提供的抽象是开发AI应用的基础。<br>Spring AI提供了以下功能</p>
<ul>
<li>跨多家 AI 提供商的 Chat、文本转图像和嵌入模型的可移植 API 支持。支持同步和流式A PI 选项。</li>
<li>支持所有主要的 AI 模型提供商，如 Anthropic、OpenAI、微软、亚马逊、谷歌和 Ollama。支持的模型类型包括：<ul>
<li>对话补全</li>
<li>潜入</li>
<li>文生图</li>
<li>音频转录</li>
<li>文本转语音</li>
<li>内容审核</li>
</ul>
</li>
<li>结构化输出 - 将 AI 模型输出映射到 POJO。</li>
<li>跨向量数据库提供商的可移植API</li>
</ul>
<h2 id="2-引入Maven坐标"><a href="#2-引入Maven坐标" class="headerlink" title="2. 引入Maven坐标"></a>2. 引入Maven坐标</h2><table>
<thead>
<tr>
<th>组件</th>
<th>版本要求</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>JDK</td>
<td>17+</td>
<td>推荐LTS版本</td>
</tr>
<tr>
<td>Spring Boot</td>
<td>3.0+</td>
<td>需支持Java 17</td>
</tr>
<tr>
<td>Maven</td>
<td>3.8+</td>
<td>或Gradle 7.5+</td>
</tr>
<tr>
<td>OpenAI API</td>
<td>自行选择模型</td>
<td>需申请API Key</td>
</tr>
</tbody></table>
<p>在pom.xml中添加Spring AI Starter依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;17&lt;/java.version&gt;</span><br><span class="line">    &lt;spring-ai.version&gt;1.0.0-M6&lt;/spring-ai.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h2><p>application.yml中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ai:</span><br><span class="line">  openai:</span><br><span class="line">    api-key: $&#123;OPENAI_API_KEY&#125;</span><br><span class="line">    base-url: https://dashscope.aliyuncs.com/compatible-mode</span><br><span class="line">    chat:</span><br><span class="line">      options:</span><br><span class="line">        model: qwen-turbo</span><br><span class="line">        max-tokens: 2000</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>api-key</code></td>
<td>OpenAI的API密钥，用于身份验证和API调用授权</td>
</tr>
<tr>
<td><code>base-url</code></td>
<td>指定AI服务的API端点地址</td>
</tr>
<tr>
<td><code>model</code> (chat)</td>
<td>指定使用的聊天模型，决定AI的能力和成本</td>
</tr>
<tr>
<td><code>temperature</code></td>
<td>控制输出的随机性和创造性，取值0.0-2.0，越低越确定，越高越有创意</td>
</tr>
<tr>
<td><code>max-tokens</code></td>
<td>限制单次响应的最大token数量，控制回复长度和API成本</td>
</tr>
<tr>
<td><code>model</code> (embedding)</td>
<td>用于文本向量化的嵌入模型，用于语义搜索、相似度计算等场景</td>
</tr>
</tbody></table>
<h2 id="4-使用阿里云的模型服务平台"><a href="#4-使用阿里云的模型服务平台" class="headerlink" title="4.使用阿里云的模型服务平台"></a>4.使用阿里云的模型服务平台</h2><p>阿里云可以提供100万token的免费额度，所以可以接入阿里的模型。<br>阿里的官方文档:<a href="https://help.aliyun.com/zh/model-studio/compatibility-of-openai-with-dashscope">https://help.aliyun.com/zh/model-studio/compatibility-of-openai-with-dashscope</a></p>
<table>
<thead>
<tr>
<th>页面</th>
<th align="left">网址</th>
</tr>
</thead>
<tbody><tr>
<td>配置API Key</td>
<td align="left"><a href="https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.6029533aOs1B0X&tab=model#/api-key">https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.6029533aOs1B0X&amp;tab=model#/api-key</a></td>
</tr>
<tr>
<td>查看模型用量</td>
<td align="left"><a href="https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.5211175fiLZA7q&tab=model#/model-usage/free-quota">https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.5211175fiLZA7q&amp;tab=model#/model-usage/free-quota</a></td>
</tr>
</tbody></table>
<h2 id="5-demo"><a href="#5-demo" class="headerlink" title="5.demo"></a>5.demo</h2><h3 id="5-1-配置bean"><a href="#5-1-配置bean" class="headerlink" title="5.1 配置bean"></a>5.1 配置bean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Spring AI ChatClient 配置类</span><br><span class="line"> * 用于创建和配置 ChatClient bean，以支持 Spring AI 的聊天功能</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class ChatClientConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建 ChatClient bean，用于与 AI 模型交互</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ChatClient gameChatClient(ChatModel chatModel) &#123;</span><br><span class="line">        return ChatClient.builder(chatModel)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-编写接口"><a href="#5-2-编写接口" class="headerlink" title="5.2 编写接口"></a>5.2 编写接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/chat&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class ChatController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/send&quot;)</span><br><span class="line">    public String chat(@RequestBody String message) &#123;</span><br><span class="line">        return chatClient.prompt()</span><br><span class="line">                .user(message)</span><br><span class="line">                .call()</span><br><span class="line">                .content();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return 流式响应结果</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/stream&quot;)</span><br><span class="line">    public Flux&lt;String&gt; streamChat(@RequestParam String message) &#123;</span><br><span class="line">        return chatClient.prompt()</span><br><span class="line">                .user(message)</span><br><span class="line">                .stream()</span><br><span class="line">                .content();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看一下效果</p>
<p><img src="/2026/01/29/Spring%E6%8E%A5%E5%85%A5AI%E6%A8%A1%E5%9E%8B/image-20260129161612068.png" alt="image-20260129161612068"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Agent应用</title>
    <url>/2026/01/29/Agent%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>用Spring AI调用模型大概是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chatClient.prompt()           // 1. 创建prompt构建器</span><br><span class="line">    .user(message)            // 2. 设置用户消息</span><br><span class="line">    .system(systemPrompt)     // 3. 设置系统提示词（可选）</span><br><span class="line">    .options(options)         // 4. 设置模型参数（可选）</span><br><span class="line">    .call()                   // 5. 执行调用</span><br><span class="line">    .content();               // 6. 获取结果</span><br></pre></td></tr></table></figure>

<p>每个参数都会对结果产生影响</p>
<h2 id="1-输出模式"><a href="#1-输出模式" class="headerlink" title="1. 输出模式"></a>1. 输出模式</h2><p>在成熟的产品中，我们和AI对话时，AI会把生成的结果一点点呈现出来，就像打字机一样，这是流式输出。<br><img src="/2026/01/29/Agent%E5%BA%94%E7%94%A8/image-20260129163724725.png" alt="image-20260129163724725"></p>
<p>Spring AI为我们提供了两种输出模式</p>
<ul>
<li>同步输出模式：客户端发送请求后会等待，直到AI模型生成完整的响应内容后一次性返回</li>
<li>流式输出模式：流式输出采用SSE技术，AI模型生成内容时会逐步推送给客户端</li>
</ul>
<h3 id="1-1-同步输出"><a href="#1-1-同步输出" class="headerlink" title="1.1 同步输出"></a>1.1 同步输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String chat(@RequestBody String message) &#123;</span><br><span class="line">        return chatClient.prompt()</span><br><span class="line">                .user(message)</span><br><span class="line">                .call()</span><br><span class="line">                .content();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ChatClient提供call方法，一次性返回所有结果</p>
<h3 id="1-2-流式输出"><a href="#1-2-流式输出" class="headerlink" title="1.2 流式输出"></a>1.2 流式输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Flux&lt;String&gt; streamChat(@RequestParam String message) &#123;</span><br><span class="line">       return chatClient.prompt()</span><br><span class="line">               .user(message)</span><br><span class="line">               .stream()</span><br><span class="line">               .content();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ChatClient提供stream方法，流式输出，使用Flux返回结果</p>
<h3 id="1-3-输出模式对比"><a href="#1-3-输出模式对比" class="headerlink" title="1.3 输出模式对比"></a>1.3 输出模式对比</h3><p>流式输出通常是更好的选择，因为和模型交互是一段比较长的时间，如果一直阻塞不给用户反馈，会带来不好的产品体验。使用流式输出，用户可以实时看到内容生成，感觉更加流畅，并且采用非阻塞IO，资源利用率高，适合长文本输出。</p>
<p>另一方面，流式输出需要前端做对应的处理，接受流式处理。</p>
<h2 id="2-提示词"><a href="#2-提示词" class="headerlink" title="2. 提示词"></a>2. 提示词</h2><p>大语言模型通过注意力机制来处理输入，提示词通过强有力的上下文信号，引导模型关注特定知识领域。</p>
<p>Spring AI提供两种方式来预设提示词</p>
<ul>
<li>调用模型时</li>
<li>创建client时</li>
</ul>
<h3 id="2-1-调用模型时"><a href="#2-1-调用模型时" class="headerlink" title="2.1 调用模型时"></a>2.1 调用模型时</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String chat(String message) &#123;</span><br><span class="line">        return chatClient.prompt()</span><br><span class="line">            .system(&quot;你是一位Java专家&quot;)  // ← 每次调用时设置</span><br><span class="line">            .user(message)</span><br><span class="line">            .call()</span><br><span class="line">            .content();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过system方法预设提示词</p>
<h3 id="2-2-创建client时"><a href="#2-2-创建client时" class="headerlink" title="2.2 创建client时"></a>2.2 创建client时</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public ChatClient getChatClient(ChatModel chatModel) &#123;</span><br><span class="line">       return ChatClient.builder(chatModel)</span><br><span class="line">               .defaultSystem(&quot;你是一位Java专家&quot;)</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-对比"><a href="#2-3-对比" class="headerlink" title="2.3 对比"></a>2.3 对比</h3><p>提示词参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 身份定位</span><br><span class="line">你是&quot;智游AI&quot;，一位专业的智能旅行规划助手。你能够整合天气、交通、景点、口碑等多源信息，为用户提供个性化、可动态调整的旅行行程规划。</span><br><span class="line"></span><br><span class="line">## 核心能力</span><br><span class="line"></span><br><span class="line">### 1. 信息整合</span><br><span class="line">实时获取并分析：天气预报、交通票价、景点客流、用户评价、餐饮住宿、特殊事件等信息。</span><br><span class="line"></span><br><span class="line">### 2. 用户理解</span><br><span class="line">深入了解用户的：预算约束、兴趣偏好、体力状况、时间安排、特殊需求、同行人员。</span><br><span class="line"></span><br><span class="line">### 3. 智能规划</span><br><span class="line">- 时空优化：合理安排景点顺序，最小化交通时间</span><br><span class="line">- 节奏控制：根据体力动态调整游览强度</span><br><span class="line">- 成本优化：在预算内最大化体验价值</span><br><span class="line">- 避峰策略：推荐人少时段，避开高峰</span><br><span class="line">- 应急预案：为关键节点提供备选方案</span><br><span class="line"></span><br><span class="line">### 4. 动态调整</span><br><span class="line">当出现天气变化、景点闭馆、体力不支、交通延误、预算超支等情况时，主动优化行程。</span><br><span class="line"></span><br><span class="line">## 工作流程</span><br><span class="line"></span><br><span class="line">### 第一步：需求收集</span><br><span class="line">友好地询问用户：</span><br><span class="line">- 📍 目的地、出行日期、天数</span><br><span class="line">- 💰 总预算及分配偏好</span><br><span class="line">- ❤️ 兴趣偏好（文化/自然/美食/休闲/冒险等）</span><br><span class="line">- 🏃 体力评估（年龄段、步行距离、游览强度）</span><br><span class="line">- 👥 同行信息及特殊需求</span><br><span class="line">- ⏰ 时间偏好（起床时间、午休、晚间活动）</span><br><span class="line"></span><br><span class="line">如信息不完整，主动询问缺失项。</span><br><span class="line"></span><br><span class="line">### 第二步：信息分析</span><br><span class="line">向用户说明正在收集信息：</span><br><span class="line">🔍 正在为您收集信息...</span><br><span class="line">✓ 已获取天气预报</span><br><span class="line">✓ 已分析景点客流</span><br><span class="line">✓ 已查询交通票价</span><br><span class="line">✓ 已整合口碑数据</span><br><span class="line">📊 数据分析完成，开始生成行程...</span><br><span class="line"></span><br><span class="line">### 第三步：行程生成</span><br><span class="line"></span><br><span class="line">按以下格式输出：</span><br><span class="line"></span><br><span class="line">```markdown</span><br><span class="line"># 🎒 您的专属旅行计划</span><br><span class="line"></span><br><span class="line">## 📋 行程概览</span><br><span class="line">- 目的地：[城市]</span><br><span class="line">- 日期：[日期]（共X天）</span><br><span class="line">- 预算：¥[总额]（预估：¥[金额]，剩余：¥[金额]）</span><br><span class="line">- 主题：[如&quot;文化探索+美食之旅&quot;]</span><br><span class="line"></span><br><span class="line">## 🌤️ 天气预报</span><br><span class="line">| 日期 | 天气 | 温度 | 建议 |</span><br><span class="line">|------|------|------|------|</span><br><span class="line">| Day1 | ☀️晴 | 18-28℃ | 适合户外 |</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 📅 Day 1：[主题]</span><br><span class="line"></span><br><span class="line">### 🌅 上午（09:00-12:00）</span><br><span class="line">#### 📍 [景点名]</span><br><span class="line">- 地址：[地址]</span><br><span class="line">- 门票：¥[价格] | 游览时长：[时间]</span><br><span class="line">- 亮点：[核心看点]</span><br><span class="line">- 客流：🟢较少 | 避坑：[提示]</span><br><span class="line">- 交通：[方式及时间]</span><br><span class="line"></span><br><span class="line">#### 🍜 午餐：[餐厅]</span><br><span class="line">- 位置：[位置] | 人均：¥[价格]</span><br><span class="line">- 特色：[菜品] | 评分：⭐⭐⭐⭐⭐ [分数]</span><br><span class="line"></span><br><span class="line">### 🌆 下午（14:00-18:00）</span><br><span class="line">[同上格式]</span><br><span class="line"></span><br><span class="line">### 🌃 晚上（19:00-21:00）</span><br><span class="line">#### 🎭 [活动]</span><br><span class="line">[活动信息]</span><br><span class="line"></span><br><span class="line">#### 🏨 住宿：[酒店]</span><br><span class="line">- 价格：¥[价格]/晚 | 评分：⭐⭐⭐⭐</span><br><span class="line">- 设施：[设施] | 理由：[选择理由]</span><br><span class="line"></span><br><span class="line">### 💡 今日小贴士</span><br><span class="line">- ⚠️ [注意事项]</span><br><span class="line">- 🎒 [携带物品]</span><br><span class="line">- 📸 [拍照建议]</span><br><span class="line"></span><br><span class="line">### 💰 今日预算：¥[金额]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 🎯 行程亮点</span><br><span class="line">1. ✨ 必打卡：[TOP3景点]</span><br><span class="line">2. 🍽️ 美食：[特色美食]</span><br><span class="line">3. 📷 拍照点：[推荐位置]</span><br><span class="line"></span><br><span class="line">## 🔄 备选方案</span><br><span class="line">- 如遇下雨：[替代方案]</span><br><span class="line">- 如时间不足：[可压缩/跳过景点]</span><br><span class="line">- 如预算超支：[节省方案]</span><br><span class="line"></span><br><span class="line">## 💬 互动提示</span><br><span class="line">您可以随时告诉我：</span><br><span class="line">- &quot;调整Day2安排&quot; → 重新规划</span><br><span class="line">- &quot;预算太紧&quot; → 更经济方案</span><br><span class="line">- &quot;增加美食&quot; → 增加美食安排</span><br><span class="line">- &quot;太累了&quot; → 降低强度</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>无提示词</th>
<th>有提示词</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2026/01/29/Agent%E5%BA%94%E7%94%A8/image-20260129173930530.png" alt="image-20260129173930530"></td>
<td><img src="/2026/01/29/Agent%E5%BA%94%E7%94%A8/image-20260129174023905.png"></td>
</tr>
</tbody></table>
<p>通过对比可以发现，在添加提示词的情况下，输出结果更加具体，质量更高。</p>
<h2 id="3-上下文"><a href="#3-上下文" class="headerlink" title="3. 上下文"></a>3. 上下文</h2><p>AI对话中的上下文就是对话的记录内容。如果AI不能记住上下文，就只能进行一次对话，无法记住前面的对话内容，不能进行多轮对话</p>
<table>
<thead>
<tr>
<th>未开启上下文</th>
<th>已开启上下文</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/image-20260129190728283.png" alt="image-20260129190728283"></td>
<td><img src="/image-20260129192008642.png" alt="image-20260129192008642"></td>
</tr>
</tbody></table>
<p>不难看出，Agent应用，应该是需要有记忆上下文的能力。</p>
<h3 id="3-1-MessageChatMemoryAdvisor"><a href="#3-1-MessageChatMemoryAdvisor" class="headerlink" title="3.1 MessageChatMemoryAdvisor"></a>3.1 MessageChatMemoryAdvisor</h3><p>Spring AI提供了MessageChatMemoryAdvisor 用来存储上下文</p>
<p><strong>加载ChatMemory</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public ChatMemory chatMemory() &#123;</span><br><span class="line">       return new InMemoryChatMemory();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建 ChatClient时，设置memory</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return ChatClient.builder(chatModel)</span><br><span class="line">						 	// 配置Advisor</span><br><span class="line">               .defaultAdvisors(new MessageChatMemoryAdvisor(chatMemory))</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Flux&lt;String&gt; chatWithMemory(String sessionId, String message)&#123;</span><br><span class="line">       return chatClient.prompt()</span><br><span class="line">               .user(message)</span><br><span class="line">               .advisors(advisorSpec -&gt; advisorSpec</span><br><span class="line">                       // 指定会话ID</span><br><span class="line">                       .param(CHAT_MEMORY_CONVERSATION_ID_KEY, sessionId)</span><br><span class="line">                       // 保留最近10轮对话</span><br><span class="line">                       .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10)</span><br><span class="line">               )</span><br><span class="line">               .stream()</span><br><span class="line">               .content();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>本质上这种方法是把对话的内容存放到内存中，然后把内容带到与模型的交互中</p>
<h3 id="3-2-Redis存储上下文"><a href="#3-2-Redis存储上下文" class="headerlink" title="3.2 Redis存储上下文"></a>3.2 Redis存储上下文</h3><p>把对话的内容以每条记录为{“角色” : “内容”}的形式记录下来，组合成MessageList。每次请求对话，加载以往的记录，调用模型，将返回值添加到已有的记录中持久保存。通过这种方式保留上下文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Flux&lt;String&gt; chatStream(String sessionId, String userMessage) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取历史消息</span><br><span class="line">            List&lt;MessageDto&gt; history = getConversationHistory(sessionId);</span><br><span class="line"></span><br><span class="line">            // 添加用户消息</span><br><span class="line">            history.add(new MessageDto(&quot;user&quot;, userMessage));</span><br><span class="line"></span><br><span class="line">            // 转换为Message对象</span><br><span class="line">            List&lt;Message&gt; messages = convertToMessages(history);</span><br><span class="line"></span><br><span class="line">            // 使用 final 变量以在 lambda 中使用</span><br><span class="line">            final List&lt;MessageDto&gt; finalHistory = history;</span><br><span class="line"></span><br><span class="line">            // 调用AI流式接口</span><br><span class="line">            return chatClient.prompt()</span><br><span class="line">                    .messages(messages)</span><br><span class="line">                    .stream()</span><br><span class="line">                    .content()</span><br><span class="line">                    .doOnNext(content -&gt; &#123;</span><br><span class="line">                        // 流式传输中不保存，在完成后保存</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .doOnComplete(() -&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            // 完成后获取完整回复并保存</span><br><span class="line">                            String assistantReply = chatClient.prompt()</span><br><span class="line">                                    .messages(messages)</span><br><span class="line">                                    .call()</span><br><span class="line">                                    .content();</span><br><span class="line"></span><br><span class="line">                            // 保存AI回复</span><br><span class="line">                            finalHistory.add(new MessageDto(&quot;assistant&quot;, assistantReply));</span><br><span class="line"></span><br><span class="line">                            // 限制消息数量</span><br><span class="line">                            List&lt;MessageDto&gt; updatedHistory = finalHistory;</span><br><span class="line">                            if (updatedHistory.size() &gt; maxMessages) &#123;</span><br><span class="line">                                updatedHistory = new ArrayList&lt;&gt;(updatedHistory.subList(updatedHistory.size() - maxMessages, updatedHistory.size()));</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            // 保存到Redis</span><br><span class="line">                            saveConversationHistory(sessionId, updatedHistory);</span><br><span class="line"></span><br><span class="line">                            log.info(&quot;Stream chat completed for session: &#123;&#125;, history size: &#123;&#125;&quot;, sessionId, updatedHistory.size());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            log.error(&quot;Error in stream chat onComplete for session: &#123;&#125;&quot;, sessionId, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .doOnError(e -&gt; log.error(&quot;Error in stream chat for session: &#123;&#125;&quot;, sessionId, e));</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;Error in chatStream for session: &#123;&#125;&quot;, sessionId, e);</span><br><span class="line">            return Flux.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Agent</tag>
      </tags>
  </entry>
</search>
